{"ast":null,"code":"import { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\nimport { useMergeRefs, useStableCallback, useUniqueId } from '@cloudscape-design/component-toolkit/internal';\nimport ScreenreaderOnly from '../../internal/components/screenreader-only';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useIntersectionObserver } from '../../internal/hooks/use-intersection-observer';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useGetGlobalBreadcrumbs } from '../../internal/plugins/helpers/use-global-breadcrumbs';\nimport globalVars from '../../internal/styles/global-vars';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport { MIN_DRAWER_SIZE, useDrawers } from '../utils/use-drawers';\nimport { useFocusControl, useMultipleFocusControl } from '../utils/use-focus-control';\nimport { useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';\nimport { ActiveDrawersContext } from '../utils/visibility-context';\nimport { computeHorizontalLayout, computeSplitPanelOffsets, computeVerticalLayout, CONTENT_PADDING } from './compute-layout';\nimport { AppLayoutVisibilityContext } from './contexts';\nimport { AppLayoutDrawer, AppLayoutGlobalDrawers, AppLayoutNavigation, AppLayoutNotifications, AppLayoutSplitPanelBottom, AppLayoutSplitPanelSide, AppLayoutToolbar } from './internal';\nimport { useMultiAppLayout } from './multi-layout';\nimport { SkeletonLayout } from './skeleton';\nconst AppLayoutVisualRefreshToolbar = React.forwardRef((_a, forwardRef) => {\n  var _b, _c;\n  var {\n      ariaLabels,\n      contentHeader,\n      content,\n      navigationOpen,\n      navigationWidth,\n      navigation,\n      navigationHide,\n      onNavigationChange,\n      tools,\n      toolsOpen: controlledToolsOpen,\n      onToolsChange,\n      toolsHide,\n      toolsWidth,\n      contentType,\n      headerVariant,\n      breadcrumbs,\n      notifications,\n      stickyNotifications,\n      splitPanelPreferences: controlledSplitPanelPreferences,\n      splitPanelOpen: controlledSplitPanelOpen,\n      splitPanel,\n      splitPanelSize: controlledSplitPanelSize,\n      onSplitPanelToggle,\n      onSplitPanelResize,\n      onSplitPanelPreferencesChange,\n      disableContentPaddings,\n      minContentWidth,\n      maxContentWidth,\n      placement,\n      navigationTriggerHide\n    } = _a,\n    rest = __rest(_a, [\"ariaLabels\", \"contentHeader\", \"content\", \"navigationOpen\", \"navigationWidth\", \"navigation\", \"navigationHide\", \"onNavigationChange\", \"tools\", \"toolsOpen\", \"onToolsChange\", \"toolsHide\", \"toolsWidth\", \"contentType\", \"headerVariant\", \"breadcrumbs\", \"notifications\", \"stickyNotifications\", \"splitPanelPreferences\", \"splitPanelOpen\", \"splitPanel\", \"splitPanelSize\", \"onSplitPanelToggle\", \"onSplitPanelResize\", \"onSplitPanelPreferencesChange\", \"disableContentPaddings\", \"minContentWidth\", \"maxContentWidth\", \"placement\", \"navigationTriggerHide\"]);\n  const isMobile = useMobile();\n  const {\n    __embeddedViewMode: embeddedViewMode,\n    __forceDeduplicationType: forceDeduplicationType\n  } = rest;\n  const splitPanelControlId = useUniqueId('split-panel');\n  const [toolbarState, setToolbarState] = useState('show');\n  const [toolbarHeight, setToolbarHeight] = useState(0);\n  const [notificationsHeight, setNotificationsHeight] = useState(0);\n  const [navigationAnimationDisabled, setNavigationAnimationDisabled] = useState(true);\n  const [splitPanelAnimationDisabled, setSplitPanelAnimationDisabled] = useState(true);\n  const [isNested, setIsNested] = useState(false);\n  const rootRef = useRef(null);\n  const [toolsOpen = false, setToolsOpen] = useControllable(controlledToolsOpen, onToolsChange, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'toolsOpen',\n    changeHandler: 'onToolsChange'\n  });\n  const onToolsToggle = open => {\n    setToolsOpen(open);\n    drawersFocusControl.setFocus();\n    fireNonCancelableEvent(onToolsChange, {\n      open\n    });\n  };\n  const onGlobalDrawerFocus = (drawerId, open) => {\n    globalDrawersFocusControl.setFocus({\n      force: true,\n      drawerId,\n      open\n    });\n  };\n  const onAddNewActiveDrawer = drawerId => {\n    var _a, _b;\n    // If a local drawer is already open, and we attempt to open a new one,\n    // it will replace the existing one instead of opening an additional drawer,\n    // since only one local drawer is supported. Therefore, layout calculations are not necessary.\n    if (activeDrawer && (drawers === null || drawers === void 0 ? void 0 : drawers.find(drawer => drawer.id === drawerId))) {\n      return;\n    }\n    // get the size of drawerId. it could be either local or global drawer\n    const combinedDrawers = [...(drawers || []), ...globalDrawers];\n    const newDrawer = combinedDrawers.find(drawer => drawer.id === drawerId);\n    if (!newDrawer) {\n      return;\n    }\n    const newDrawerSize = Math.min((_b = (_a = newDrawer.defaultSize) !== null && _a !== void 0 ? _a : drawerSizes[drawerId]) !== null && _b !== void 0 ? _b : MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n    //   check if the active drawers could be resized to fit the new drawers\n    //   to do this, we need to take all active drawers, sum up their min sizes, truncate it from resizableSpaceAvailable\n    //   and compare a given number with the new drawer id min size\n    // the total size of all global drawers resized to their min size\n    const availableSpaceForNewDrawer = resizableSpaceAvailable - totalActiveDrawersMinSize;\n    if (availableSpaceForNewDrawer >= newDrawerSize) {\n      return;\n    }\n    // now we made sure we cannot accommodate the new drawer with existing ones\n    closeFirstDrawer();\n  };\n  const {\n    drawers,\n    activeDrawer,\n    minDrawerSize,\n    minGlobalDrawersSizes,\n    activeDrawerSize,\n    ariaLabelsWithDrawers,\n    globalDrawers,\n    activeGlobalDrawers,\n    activeGlobalDrawersIds,\n    activeGlobalDrawersSizes,\n    drawerSizes,\n    drawersOpenQueue,\n    onActiveDrawerChange,\n    onActiveDrawerResize,\n    onActiveGlobalDrawersChange,\n    expandedDrawerId,\n    setExpandedDrawerId\n  } = useDrawers(Object.assign(Object.assign({}, rest), {\n    onGlobalDrawerFocus,\n    onAddNewActiveDrawer\n  }), ariaLabels, {\n    ariaLabels,\n    toolsHide,\n    toolsOpen,\n    tools,\n    toolsWidth,\n    onToolsToggle\n  });\n  const onActiveDrawerChangeHandler = function (drawerId) {\n    let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      initiatedByUserAction: true\n    };\n    onActiveDrawerChange(drawerId, params);\n    drawersFocusControl.setFocus();\n  };\n  const [splitPanelOpen = false, setSplitPanelOpen] = useControllable(controlledSplitPanelOpen, onSplitPanelToggle, false, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelOpen',\n    changeHandler: 'onSplitPanelToggle'\n  });\n  const onSplitPanelToggleHandler = () => {\n    setSplitPanelAnimationDisabled(false);\n    setSplitPanelOpen(!splitPanelOpen);\n    splitPanelFocusControl.setLastInteraction({\n      type: splitPanelOpen ? 'close' : 'open'\n    });\n    fireNonCancelableEvent(onSplitPanelToggle, {\n      open: !splitPanelOpen\n    });\n  };\n  const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(controlledSplitPanelPreferences, onSplitPanelPreferencesChange, undefined, {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelPreferences',\n    changeHandler: 'onSplitPanelPreferencesChange'\n  });\n  const onSplitPanelPreferencesChangeHandler = detail => {\n    setSplitPanelPreferences(detail);\n    splitPanelFocusControl.setLastInteraction({\n      type: 'position'\n    });\n    fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);\n  };\n  const [splitPanelSize = 0, setSplitPanelSize] = useControllable(controlledSplitPanelSize, onSplitPanelResize, getSplitPanelDefaultSize((_b = splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position) !== null && _b !== void 0 ? _b : 'bottom'), {\n    componentName: 'AppLayout',\n    controlledProp: 'splitPanelSize',\n    changeHandler: 'onSplitPanelResize'\n  });\n  const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n  const [splitPanelHeaderBlockSize, setSplitPanelHeaderBlockSize] = useState(0);\n  const onSplitPanelResizeHandler = size => {\n    setSplitPanelSize(size);\n    fireNonCancelableEvent(onSplitPanelResize, {\n      size\n    });\n  };\n  const [splitPanelToggleConfig, setSplitPanelToggleConfig] = useState({\n    ariaLabel: undefined,\n    displayed: false\n  });\n  const globalDrawersFocusControl = useMultipleFocusControl(true, activeGlobalDrawersIds);\n  const drawersFocusControl = useFocusControl(!!(activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id), true, activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id);\n  const navigationFocusControl = useFocusControl(navigationOpen, navigationTriggerHide);\n  const splitPanelFocusControl = useSplitPanelFocusControl([splitPanelPreferences, splitPanelOpen]);\n  const onNavigationToggle = useStableCallback(open => {\n    setNavigationAnimationDisabled(false);\n    navigationFocusControl.setFocus();\n    fireNonCancelableEvent(onNavigationChange, {\n      open\n    });\n  });\n  useImperativeHandle(forwardRef, () => ({\n    closeNavigationIfNecessary: () => isMobile && onNavigationToggle(false),\n    openTools: () => onToolsToggle(true),\n    focusToolsClose: () => drawersFocusControl.setFocus(true),\n    focusActiveDrawer: () => drawersFocusControl.setFocus(true),\n    focusSplitPanel: () => {\n      var _a;\n      return (_a = splitPanelFocusControl.refs.slider.current) === null || _a === void 0 ? void 0 : _a.focus();\n    },\n    focusNavigation: () => navigationFocusControl.setFocus(true)\n  }));\n  const resolvedStickyNotifications = !!stickyNotifications && !isMobile;\n  //navigation must be null if hidden so toolbar knows to hide the toggle button\n  const resolvedNavigation = navigationHide ? null : navigation || React.createElement(React.Fragment, null);\n  //navigation must not be open if navigationHide is true\n  const resolvedNavigationOpen = !!resolvedNavigation && navigationOpen;\n  const {\n    maxDrawerSize,\n    maxSplitPanelSize,\n    splitPanelForcedPosition,\n    splitPanelPosition,\n    maxGlobalDrawersSizes,\n    resizableSpaceAvailable\n  } = computeHorizontalLayout({\n    activeDrawerSize: activeDrawer ? activeDrawerSize : 0,\n    splitPanelSize,\n    minContentWidth,\n    navigationOpen: resolvedNavigationOpen,\n    navigationWidth,\n    placement,\n    splitPanelOpen,\n    splitPanelPosition: splitPanelPreferences === null || splitPanelPreferences === void 0 ? void 0 : splitPanelPreferences.position,\n    isMobile,\n    activeGlobalDrawersSizes\n  });\n  const {\n    ref: intersectionObserverRef,\n    isIntersecting\n  } = useIntersectionObserver({\n    initialState: true\n  });\n  const {\n    registered,\n    toolbarProps\n  } = useMultiAppLayout({\n    forceDeduplicationType,\n    ariaLabels: ariaLabelsWithDrawers,\n    navigation: resolvedNavigation && !navigationTriggerHide,\n    navigationOpen: resolvedNavigationOpen,\n    onNavigationToggle,\n    navigationFocusRef: navigationFocusControl.refs.toggle,\n    breadcrumbs,\n    activeDrawerId: (_c = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id) !== null && _c !== void 0 ? _c : null,\n    // only pass it down if there are non-empty drawers or tools\n    drawers: (drawers === null || drawers === void 0 ? void 0 : drawers.length) || !toolsHide ? drawers : undefined,\n    globalDrawersFocusControl,\n    globalDrawers: (globalDrawers === null || globalDrawers === void 0 ? void 0 : globalDrawers.length) ? globalDrawers : undefined,\n    activeGlobalDrawersIds,\n    onActiveGlobalDrawersChange,\n    onActiveDrawerChange: onActiveDrawerChangeHandler,\n    drawersFocusRef: drawersFocusControl.refs.toggle,\n    splitPanel,\n    splitPanelToggleProps: Object.assign(Object.assign({}, splitPanelToggleConfig), {\n      active: splitPanelOpen,\n      controlId: splitPanelControlId,\n      position: splitPanelPosition\n    }),\n    splitPanelFocusRef: splitPanelFocusControl.refs.toggle,\n    onSplitPanelToggle: onSplitPanelToggleHandler,\n    expandedDrawerId,\n    setExpandedDrawerId\n  }, isIntersecting);\n  const hasToolbar = !embeddedViewMode && !!toolbarProps;\n  const discoveredBreadcrumbs = useGetGlobalBreadcrumbs(hasToolbar && !breadcrumbs);\n  const verticalOffsets = computeVerticalLayout({\n    topOffset: placement.insetBlockStart,\n    hasVisibleToolbar: hasToolbar && toolbarState !== 'hide',\n    notificationsHeight: notificationsHeight !== null && notificationsHeight !== void 0 ? notificationsHeight : 0,\n    toolbarHeight: toolbarHeight !== null && toolbarHeight !== void 0 ? toolbarHeight : 0,\n    stickyNotifications: resolvedStickyNotifications\n  });\n  const appLayoutInternals = {\n    ariaLabels: ariaLabelsWithDrawers,\n    headerVariant,\n    isMobile,\n    breadcrumbs,\n    discoveredBreadcrumbs,\n    stickyNotifications: resolvedStickyNotifications,\n    navigationOpen: resolvedNavigationOpen,\n    navigation: resolvedNavigation,\n    navigationFocusControl,\n    activeDrawer,\n    activeDrawerSize,\n    minDrawerSize,\n    maxDrawerSize,\n    minGlobalDrawersSizes,\n    maxGlobalDrawersSizes,\n    drawers: drawers,\n    globalDrawers,\n    activeGlobalDrawers,\n    activeGlobalDrawersIds,\n    activeGlobalDrawersSizes,\n    onActiveGlobalDrawersChange,\n    drawersFocusControl,\n    globalDrawersFocusControl,\n    splitPanelPosition,\n    splitPanelToggleConfig,\n    splitPanelOpen,\n    splitPanelControlId,\n    splitPanelFocusControl,\n    placement,\n    toolbarState,\n    setToolbarState,\n    verticalOffsets,\n    drawersOpenQueue,\n    setToolbarHeight,\n    setNotificationsHeight,\n    onSplitPanelToggle: onSplitPanelToggleHandler,\n    onNavigationToggle,\n    onActiveDrawerChange: onActiveDrawerChangeHandler,\n    onActiveDrawerResize,\n    splitPanelAnimationDisabled,\n    expandedDrawerId,\n    setExpandedDrawerId\n  };\n  const splitPanelInternals = {\n    bottomOffset: 0,\n    getMaxHeight: () => {\n      const availableHeight = document.documentElement.clientHeight - placement.insetBlockStart - placement.insetBlockEnd;\n      // If the page is likely zoomed in at 200%, allow the split panel to fill the content area.\n      return availableHeight < 400 ? availableHeight - 40 : availableHeight - 250;\n    },\n    maxWidth: maxSplitPanelSize,\n    isForcedPosition: splitPanelForcedPosition,\n    isOpen: splitPanelOpen,\n    leftOffset: 0,\n    onPreferencesChange: onSplitPanelPreferencesChangeHandler,\n    onResize: onSplitPanelResizeHandler,\n    onToggle: onSplitPanelToggleHandler,\n    position: splitPanelPosition,\n    reportSize: size => setSplitPanelReportedSize(size),\n    reportHeaderHeight: size => setSplitPanelHeaderBlockSize(size),\n    headerHeight: splitPanelHeaderBlockSize,\n    rightOffset: 0,\n    size: splitPanelSize,\n    topOffset: 0,\n    setSplitPanelToggle: setSplitPanelToggleConfig,\n    refs: splitPanelFocusControl.refs\n  };\n  const closeFirstDrawer = useStableCallback(() => {\n    const drawerToClose = drawersOpenQueue[drawersOpenQueue.length - 1];\n    if (activeDrawer && (activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.id) === drawerToClose) {\n      onActiveDrawerChange(null, {\n        initiatedByUserAction: true\n      });\n    } else if (activeGlobalDrawersIds.includes(drawerToClose)) {\n      onActiveGlobalDrawersChange(drawerToClose, {\n        initiatedByUserAction: true\n      });\n    }\n  });\n  useEffect(() => {\n    // Close navigation drawer on mobile so that the main content is visible\n    if (isMobile) {\n      onNavigationToggle(false);\n    }\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isMobile]);\n  const getTotalActiveDrawersMinSize = () => {\n    var _a;\n    const combinedDrawers = [...(drawers || []), ...globalDrawers];\n    let result = activeGlobalDrawersIds.map(activeDrawerId => {\n      var _a, _b;\n      return Math.min((_b = (_a = combinedDrawers.find(drawer => drawer.id === activeDrawerId)) === null || _a === void 0 ? void 0 : _a.defaultSize) !== null && _b !== void 0 ? _b : MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n    }).reduce((acc, curr) => acc + curr, 0);\n    if (activeDrawer) {\n      result += Math.min((_a = activeDrawer === null || activeDrawer === void 0 ? void 0 : activeDrawer.defaultSize) !== null && _a !== void 0 ? _a : MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n    }\n    return result;\n  };\n  const totalActiveDrawersMinSize = getTotalActiveDrawersMinSize();\n  useEffect(() => {\n    if (isMobile) {\n      return;\n    }\n    const activeNavigationWidth = !navigationHide && navigationOpen ? navigationWidth : 0;\n    const scrollWidth = activeNavigationWidth + CONTENT_PADDING + totalActiveDrawersMinSize;\n    const hasHorizontalScroll = scrollWidth > placement.inlineSize;\n    if (hasHorizontalScroll) {\n      if (!navigationHide && navigationOpen) {\n        onNavigationToggle(false);\n        return;\n      }\n      closeFirstDrawer();\n    }\n  }, [totalActiveDrawersMinSize, closeFirstDrawer, isMobile, navigationHide, navigationOpen, navigationWidth, onNavigationToggle, placement.inlineSize]);\n  /**\n   * Returns true if the AppLayout is nested\n   * Does not apply to iframe\n   */\n  const getIsNestedInAppLayout = element => {\n    var _a;\n    let currentElement = (_a = element === null || element === void 0 ? void 0 : element.parentElement) !== null && _a !== void 0 ? _a : null;\n    // this traverse is needed only for JSDOM\n    // in real browsers the globalVar will be propagated to all descendants and this loops exits after initial iteration\n    while (currentElement) {\n      if (getComputedStyle(currentElement).getPropertyValue(globalVars.stickyVerticalTopOffset)) {\n        return true;\n      }\n      currentElement = currentElement.parentElement;\n    }\n    return false;\n  };\n  useLayoutEffect(() => {\n    if (!hasToolbar) {\n      setIsNested(getIsNestedInAppLayout(rootRef.current));\n    }\n  }, [hasToolbar]);\n  const splitPanelOffsets = computeSplitPanelOffsets({\n    placement,\n    hasSplitPanel: !!splitPanel,\n    splitPanelOpen,\n    splitPanelPosition,\n    splitPanelFullHeight: splitPanelReportedSize,\n    splitPanelHeaderHeight: splitPanelHeaderBlockSize\n  });\n  return React.createElement(AppLayoutVisibilityContext.Provider, {\n    value: isIntersecting\n  }, !hasToolbar && breadcrumbs ? React.createElement(ScreenreaderOnly, null, breadcrumbs) : null, React.createElement(SkeletonLayout, {\n    ref: useMergeRefs(intersectionObserverRef, rootRef),\n    isNested: isNested,\n    // Why not use drawerExpandedMode={!!expandedDrawerId || !!toolbarProps?.expandedDrawerId} instead?\n    // Because in nested layouts, the parent layout hides its main content area,\n    // which means the child layout isn't rendered at all in that case\n    drawerExpandedModeInChildLayout: !!(toolbarProps === null || toolbarProps === void 0 ? void 0 : toolbarProps.expandedDrawerId),\n    drawerExpandedMode: !!expandedDrawerId,\n    style: Object.assign(Object.assign({\n      paddingBlockEnd: splitPanelOffsets.mainContentPaddingBlockEnd\n    }, hasToolbar || !isNested ? {\n      [globalVars.stickyVerticalTopOffset]: `${verticalOffsets.header}px`,\n      [globalVars.stickyVerticalBottomOffset]: `${splitPanelOffsets.stickyVerticalBottomOffset}px`\n    } : {}), !isMobile ? {\n      minWidth: `${minContentWidth}px`\n    } : {}),\n    toolbar: hasToolbar && React.createElement(AppLayoutToolbar, {\n      appLayoutInternals: appLayoutInternals,\n      toolbarProps: toolbarProps\n    }),\n    notifications: notifications && React.createElement(AppLayoutNotifications, {\n      appLayoutInternals: appLayoutInternals\n    }, notifications),\n    headerVariant: headerVariant,\n    contentHeader: contentHeader,\n    // delay rendering the content until registration of this instance is complete\n    content: registered ? content : null,\n    navigation: resolvedNavigation && React.createElement(AppLayoutNavigation, {\n      appLayoutInternals: appLayoutInternals\n    }),\n    navigationOpen: resolvedNavigationOpen,\n    navigationWidth: navigationWidth,\n    navigationAnimationDisabled: navigationAnimationDisabled,\n    tools: drawers && drawers.length > 0 && React.createElement(AppLayoutDrawer, {\n      appLayoutInternals: appLayoutInternals\n    }),\n    globalTools: React.createElement(ActiveDrawersContext.Provider, {\n      value: activeGlobalDrawersIds\n    }, React.createElement(AppLayoutGlobalDrawers, {\n      appLayoutInternals: appLayoutInternals\n    })),\n    globalToolsOpen: !!activeGlobalDrawersIds.length,\n    toolsOpen: !!activeDrawer,\n    toolsWidth: activeDrawerSize,\n    sideSplitPanel: splitPanelPosition === 'side' && React.createElement(AppLayoutSplitPanelSide, {\n      appLayoutInternals: appLayoutInternals,\n      splitPanelInternals: splitPanelInternals\n    }, splitPanel),\n    bottomSplitPanel: splitPanelPosition === 'bottom' && React.createElement(AppLayoutSplitPanelBottom, {\n      appLayoutInternals: appLayoutInternals,\n      splitPanelInternals: splitPanelInternals\n    }, splitPanel),\n    splitPanelOpen: splitPanelOpen,\n    placement: placement,\n    contentType: contentType,\n    maxContentWidth: maxContentWidth,\n    disableContentPaddings: disableContentPaddings\n  }));\n});\nexport default AppLayoutVisualRefreshToolbar;","map":{"version":3,"names":["React","useEffect","useImperativeHandle","useLayoutEffect","useRef","useState","useMergeRefs","useStableCallback","useUniqueId","ScreenreaderOnly","fireNonCancelableEvent","useControllable","useIntersectionObserver","useMobile","useGetGlobalBreadcrumbs","globalVars","getSplitPanelDefaultSize","MIN_DRAWER_SIZE","useDrawers","useFocusControl","useMultipleFocusControl","useSplitPanelFocusControl","ActiveDrawersContext","computeHorizontalLayout","computeSplitPanelOffsets","computeVerticalLayout","CONTENT_PADDING","AppLayoutVisibilityContext","AppLayoutDrawer","AppLayoutGlobalDrawers","AppLayoutNavigation","AppLayoutNotifications","AppLayoutSplitPanelBottom","AppLayoutSplitPanelSide","AppLayoutToolbar","useMultiAppLayout","SkeletonLayout","AppLayoutVisualRefreshToolbar","forwardRef","_a","ariaLabels","contentHeader","content","navigationOpen","navigationWidth","navigation","navigationHide","onNavigationChange","tools","toolsOpen","controlledToolsOpen","onToolsChange","toolsHide","toolsWidth","contentType","headerVariant","breadcrumbs","notifications","stickyNotifications","splitPanelPreferences","controlledSplitPanelPreferences","splitPanelOpen","controlledSplitPanelOpen","splitPanel","splitPanelSize","controlledSplitPanelSize","onSplitPanelToggle","onSplitPanelResize","onSplitPanelPreferencesChange","disableContentPaddings","minContentWidth","maxContentWidth","placement","navigationTriggerHide","rest","__rest","isMobile","__embeddedViewMode","embeddedViewMode","__forceDeduplicationType","forceDeduplicationType","splitPanelControlId","toolbarState","setToolbarState","toolbarHeight","setToolbarHeight","notificationsHeight","setNotificationsHeight","navigationAnimationDisabled","setNavigationAnimationDisabled","splitPanelAnimationDisabled","setSplitPanelAnimationDisabled","isNested","setIsNested","rootRef","setToolsOpen","componentName","controlledProp","changeHandler","onToolsToggle","open","drawersFocusControl","setFocus","onGlobalDrawerFocus","drawerId","globalDrawersFocusControl","force","onAddNewActiveDrawer","activeDrawer","drawers","find","drawer","id","combinedDrawers","globalDrawers","newDrawer","newDrawerSize","Math","min","_b","defaultSize","drawerSizes","availableSpaceForNewDrawer","resizableSpaceAvailable","totalActiveDrawersMinSize","closeFirstDrawer","minDrawerSize","minGlobalDrawersSizes","activeDrawerSize","ariaLabelsWithDrawers","activeGlobalDrawers","activeGlobalDrawersIds","activeGlobalDrawersSizes","drawersOpenQueue","onActiveDrawerChange","onActiveDrawerResize","onActiveGlobalDrawersChange","expandedDrawerId","setExpandedDrawerId","Object","assign","onActiveDrawerChangeHandler","params","arguments","length","undefined","initiatedByUserAction","setSplitPanelOpen","onSplitPanelToggleHandler","splitPanelFocusControl","setLastInteraction","type","setSplitPanelPreferences","onSplitPanelPreferencesChangeHandler","detail","setSplitPanelSize","position","splitPanelReportedSize","setSplitPanelReportedSize","splitPanelHeaderBlockSize","setSplitPanelHeaderBlockSize","onSplitPanelResizeHandler","size","splitPanelToggleConfig","setSplitPanelToggleConfig","ariaLabel","displayed","navigationFocusControl","onNavigationToggle","closeNavigationIfNecessary","openTools","focusToolsClose","focusActiveDrawer","focusSplitPanel","refs","slider","current","focus","focusNavigation","resolvedStickyNotifications","resolvedNavigation","createElement","Fragment","resolvedNavigationOpen","maxDrawerSize","maxSplitPanelSize","splitPanelForcedPosition","splitPanelPosition","maxGlobalDrawersSizes","ref","intersectionObserverRef","isIntersecting","initialState","registered","toolbarProps","navigationFocusRef","toggle","activeDrawerId","_c","drawersFocusRef","splitPanelToggleProps","active","controlId","splitPanelFocusRef","hasToolbar","discoveredBreadcrumbs","verticalOffsets","topOffset","insetBlockStart","hasVisibleToolbar","appLayoutInternals","splitPanelInternals","bottomOffset","getMaxHeight","availableHeight","document","documentElement","clientHeight","insetBlockEnd","maxWidth","isForcedPosition","isOpen","leftOffset","onPreferencesChange","onResize","onToggle","reportSize","reportHeaderHeight","headerHeight","rightOffset","setSplitPanelToggle","drawerToClose","includes","getTotalActiveDrawersMinSize","result","map","reduce","acc","curr","activeNavigationWidth","scrollWidth","hasHorizontalScroll","inlineSize","getIsNestedInAppLayout","element","currentElement","parentElement","getComputedStyle","getPropertyValue","stickyVerticalTopOffset","splitPanelOffsets","hasSplitPanel","splitPanelFullHeight","splitPanelHeaderHeight","Provider","value","drawerExpandedModeInChildLayout","drawerExpandedMode","style","paddingBlockEnd","mainContentPaddingBlockEnd","header","stickyVerticalBottomOffset","minWidth","toolbar","globalTools","globalToolsOpen","sideSplitPanel","bottomSplitPanel"],"sources":["/Users/naman/Desktop/Portfolio/react-portfolio/node_modules/src/app-layout/visual-refresh-toolbar/index.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useImperativeHandle, useLayoutEffect, useRef, useState } from 'react';\n\nimport { useMergeRefs, useStableCallback, useUniqueId } from '@cloudscape-design/component-toolkit/internal';\n\nimport ScreenreaderOnly from '../../internal/components/screenreader-only';\nimport { SplitPanelSideToggleProps } from '../../internal/context/split-panel-context';\nimport { fireNonCancelableEvent } from '../../internal/events';\nimport { useControllable } from '../../internal/hooks/use-controllable';\nimport { useIntersectionObserver } from '../../internal/hooks/use-intersection-observer';\nimport { useMobile } from '../../internal/hooks/use-mobile';\nimport { useGetGlobalBreadcrumbs } from '../../internal/plugins/helpers/use-global-breadcrumbs';\nimport globalVars from '../../internal/styles/global-vars';\nimport { getSplitPanelDefaultSize } from '../../split-panel/utils/size-utils';\nimport { AppLayoutProps } from '../interfaces';\nimport { SplitPanelProviderProps } from '../split-panel';\nimport { MIN_DRAWER_SIZE, OnChangeParams, useDrawers } from '../utils/use-drawers';\nimport { useFocusControl, useMultipleFocusControl } from '../utils/use-focus-control';\nimport { useSplitPanelFocusControl } from '../utils/use-split-panel-focus-control';\nimport { ActiveDrawersContext } from '../utils/visibility-context';\nimport {\n  computeHorizontalLayout,\n  computeSplitPanelOffsets,\n  computeVerticalLayout,\n  CONTENT_PADDING,\n} from './compute-layout';\nimport { AppLayoutVisibilityContext } from './contexts';\nimport { AppLayoutInternalProps, AppLayoutInternals } from './interfaces';\nimport {\n  AppLayoutDrawer,\n  AppLayoutGlobalDrawers,\n  AppLayoutNavigation,\n  AppLayoutNotifications,\n  AppLayoutSplitPanelBottom,\n  AppLayoutSplitPanelSide,\n  AppLayoutToolbar,\n} from './internal';\nimport { useMultiAppLayout } from './multi-layout';\nimport { SkeletonLayout } from './skeleton';\n\nconst AppLayoutVisualRefreshToolbar = React.forwardRef<AppLayoutProps.Ref, AppLayoutInternalProps>(\n  (\n    {\n      ariaLabels,\n      contentHeader,\n      content,\n      navigationOpen,\n      navigationWidth,\n      navigation,\n      navigationHide,\n      onNavigationChange,\n      tools,\n      toolsOpen: controlledToolsOpen,\n      onToolsChange,\n      toolsHide,\n      toolsWidth,\n      contentType,\n      headerVariant,\n      breadcrumbs,\n      notifications,\n      stickyNotifications,\n      splitPanelPreferences: controlledSplitPanelPreferences,\n      splitPanelOpen: controlledSplitPanelOpen,\n      splitPanel,\n      splitPanelSize: controlledSplitPanelSize,\n      onSplitPanelToggle,\n      onSplitPanelResize,\n      onSplitPanelPreferencesChange,\n      disableContentPaddings,\n      minContentWidth,\n      maxContentWidth,\n      placement,\n      navigationTriggerHide,\n      ...rest\n    },\n    forwardRef\n  ) => {\n    const isMobile = useMobile();\n    const { __embeddedViewMode: embeddedViewMode, __forceDeduplicationType: forceDeduplicationType } = rest as any;\n    const splitPanelControlId = useUniqueId('split-panel');\n    const [toolbarState, setToolbarState] = useState<'show' | 'hide'>('show');\n    const [toolbarHeight, setToolbarHeight] = useState(0);\n    const [notificationsHeight, setNotificationsHeight] = useState(0);\n    const [navigationAnimationDisabled, setNavigationAnimationDisabled] = useState(true);\n    const [splitPanelAnimationDisabled, setSplitPanelAnimationDisabled] = useState(true);\n    const [isNested, setIsNested] = useState(false);\n    const rootRef = useRef<HTMLDivElement>(null);\n\n    const [toolsOpen = false, setToolsOpen] = useControllable(controlledToolsOpen, onToolsChange, false, {\n      componentName: 'AppLayout',\n      controlledProp: 'toolsOpen',\n      changeHandler: 'onToolsChange',\n    });\n    const onToolsToggle = (open: boolean) => {\n      setToolsOpen(open);\n      drawersFocusControl.setFocus();\n      fireNonCancelableEvent(onToolsChange, { open });\n    };\n\n    const onGlobalDrawerFocus = (drawerId: string, open: boolean) => {\n      globalDrawersFocusControl.setFocus({ force: true, drawerId, open });\n    };\n\n    const onAddNewActiveDrawer = (drawerId: string) => {\n      // If a local drawer is already open, and we attempt to open a new one,\n      // it will replace the existing one instead of opening an additional drawer,\n      // since only one local drawer is supported. Therefore, layout calculations are not necessary.\n      if (activeDrawer && drawers?.find(drawer => drawer.id === drawerId)) {\n        return;\n      }\n      // get the size of drawerId. it could be either local or global drawer\n      const combinedDrawers = [...(drawers || []), ...globalDrawers];\n      const newDrawer = combinedDrawers.find(drawer => drawer.id === drawerId);\n      if (!newDrawer) {\n        return;\n      }\n      const newDrawerSize = Math.min(\n        newDrawer.defaultSize ?? drawerSizes[drawerId] ?? MIN_DRAWER_SIZE,\n        MIN_DRAWER_SIZE\n      );\n      //   check if the active drawers could be resized to fit the new drawers\n      //   to do this, we need to take all active drawers, sum up their min sizes, truncate it from resizableSpaceAvailable\n      //   and compare a given number with the new drawer id min size\n\n      // the total size of all global drawers resized to their min size\n      const availableSpaceForNewDrawer = resizableSpaceAvailable - totalActiveDrawersMinSize;\n      if (availableSpaceForNewDrawer >= newDrawerSize) {\n        return;\n      }\n\n      // now we made sure we cannot accommodate the new drawer with existing ones\n      closeFirstDrawer();\n    };\n\n    const {\n      drawers,\n      activeDrawer,\n      minDrawerSize,\n      minGlobalDrawersSizes,\n      activeDrawerSize,\n      ariaLabelsWithDrawers,\n      globalDrawers,\n      activeGlobalDrawers,\n      activeGlobalDrawersIds,\n      activeGlobalDrawersSizes,\n      drawerSizes,\n      drawersOpenQueue,\n      onActiveDrawerChange,\n      onActiveDrawerResize,\n      onActiveGlobalDrawersChange,\n      expandedDrawerId,\n      setExpandedDrawerId,\n    } = useDrawers({ ...rest, onGlobalDrawerFocus, onAddNewActiveDrawer }, ariaLabels, {\n      ariaLabels,\n      toolsHide,\n      toolsOpen,\n      tools,\n      toolsWidth,\n      onToolsToggle,\n    });\n\n    const onActiveDrawerChangeHandler = (\n      drawerId: string | null,\n      params: OnChangeParams = { initiatedByUserAction: true }\n    ) => {\n      onActiveDrawerChange(drawerId, params);\n      drawersFocusControl.setFocus();\n    };\n\n    const [splitPanelOpen = false, setSplitPanelOpen] = useControllable(\n      controlledSplitPanelOpen,\n      onSplitPanelToggle,\n      false,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelOpen',\n        changeHandler: 'onSplitPanelToggle',\n      }\n    );\n\n    const onSplitPanelToggleHandler = () => {\n      setSplitPanelAnimationDisabled(false);\n      setSplitPanelOpen(!splitPanelOpen);\n      splitPanelFocusControl.setLastInteraction({ type: splitPanelOpen ? 'close' : 'open' });\n      fireNonCancelableEvent(onSplitPanelToggle, { open: !splitPanelOpen });\n    };\n\n    const [splitPanelPreferences, setSplitPanelPreferences] = useControllable(\n      controlledSplitPanelPreferences,\n      onSplitPanelPreferencesChange,\n      undefined,\n      {\n        componentName: 'AppLayout',\n        controlledProp: 'splitPanelPreferences',\n        changeHandler: 'onSplitPanelPreferencesChange',\n      }\n    );\n\n    const onSplitPanelPreferencesChangeHandler = (detail: AppLayoutProps.SplitPanelPreferences) => {\n      setSplitPanelPreferences(detail);\n      splitPanelFocusControl.setLastInteraction({ type: 'position' });\n      fireNonCancelableEvent(onSplitPanelPreferencesChange, detail);\n    };\n\n    const [splitPanelSize = 0, setSplitPanelSize] = useControllable(\n      controlledSplitPanelSize,\n      onSplitPanelResize,\n      getSplitPanelDefaultSize(splitPanelPreferences?.position ?? 'bottom'),\n      { componentName: 'AppLayout', controlledProp: 'splitPanelSize', changeHandler: 'onSplitPanelResize' }\n    );\n\n    const [splitPanelReportedSize, setSplitPanelReportedSize] = useState(0);\n    const [splitPanelHeaderBlockSize, setSplitPanelHeaderBlockSize] = useState(0);\n\n    const onSplitPanelResizeHandler = (size: number) => {\n      setSplitPanelSize(size);\n      fireNonCancelableEvent(onSplitPanelResize, { size });\n    };\n\n    const [splitPanelToggleConfig, setSplitPanelToggleConfig] = useState<SplitPanelSideToggleProps>({\n      ariaLabel: undefined,\n      displayed: false,\n    });\n\n    const globalDrawersFocusControl = useMultipleFocusControl(true, activeGlobalDrawersIds);\n    const drawersFocusControl = useFocusControl(!!activeDrawer?.id, true, activeDrawer?.id);\n    const navigationFocusControl = useFocusControl(navigationOpen, navigationTriggerHide);\n    const splitPanelFocusControl = useSplitPanelFocusControl([splitPanelPreferences, splitPanelOpen]);\n\n    const onNavigationToggle = useStableCallback((open: boolean) => {\n      setNavigationAnimationDisabled(false);\n      navigationFocusControl.setFocus();\n      fireNonCancelableEvent(onNavigationChange, { open });\n    });\n\n    useImperativeHandle(forwardRef, () => ({\n      closeNavigationIfNecessary: () => isMobile && onNavigationToggle(false),\n      openTools: () => onToolsToggle(true),\n      focusToolsClose: () => drawersFocusControl.setFocus(true),\n      focusActiveDrawer: () => drawersFocusControl.setFocus(true),\n      focusSplitPanel: () => splitPanelFocusControl.refs.slider.current?.focus(),\n      focusNavigation: () => navigationFocusControl.setFocus(true),\n    }));\n\n    const resolvedStickyNotifications = !!stickyNotifications && !isMobile;\n    //navigation must be null if hidden so toolbar knows to hide the toggle button\n    const resolvedNavigation = navigationHide ? null : navigation || <></>;\n    //navigation must not be open if navigationHide is true\n    const resolvedNavigationOpen = !!resolvedNavigation && navigationOpen;\n    const {\n      maxDrawerSize,\n      maxSplitPanelSize,\n      splitPanelForcedPosition,\n      splitPanelPosition,\n      maxGlobalDrawersSizes,\n      resizableSpaceAvailable,\n    } = computeHorizontalLayout({\n      activeDrawerSize: activeDrawer ? activeDrawerSize : 0,\n      splitPanelSize,\n      minContentWidth,\n      navigationOpen: resolvedNavigationOpen,\n      navigationWidth,\n      placement,\n      splitPanelOpen,\n      splitPanelPosition: splitPanelPreferences?.position,\n      isMobile,\n      activeGlobalDrawersSizes,\n    });\n\n    const { ref: intersectionObserverRef, isIntersecting } = useIntersectionObserver({ initialState: true });\n    const { registered, toolbarProps } = useMultiAppLayout(\n      {\n        forceDeduplicationType,\n        ariaLabels: ariaLabelsWithDrawers,\n        navigation: resolvedNavigation && !navigationTriggerHide,\n        navigationOpen: resolvedNavigationOpen,\n        onNavigationToggle,\n        navigationFocusRef: navigationFocusControl.refs.toggle,\n        breadcrumbs,\n        activeDrawerId: activeDrawer?.id ?? null,\n        // only pass it down if there are non-empty drawers or tools\n        drawers: drawers?.length || !toolsHide ? drawers : undefined,\n        globalDrawersFocusControl,\n        globalDrawers: globalDrawers?.length ? globalDrawers : undefined,\n        activeGlobalDrawersIds,\n        onActiveGlobalDrawersChange,\n        onActiveDrawerChange: onActiveDrawerChangeHandler,\n        drawersFocusRef: drawersFocusControl.refs.toggle,\n        splitPanel,\n        splitPanelToggleProps: {\n          ...splitPanelToggleConfig,\n          active: splitPanelOpen,\n          controlId: splitPanelControlId,\n          position: splitPanelPosition,\n        },\n        splitPanelFocusRef: splitPanelFocusControl.refs.toggle,\n        onSplitPanelToggle: onSplitPanelToggleHandler,\n        expandedDrawerId,\n        setExpandedDrawerId,\n      },\n      isIntersecting\n    );\n\n    const hasToolbar = !embeddedViewMode && !!toolbarProps;\n    const discoveredBreadcrumbs = useGetGlobalBreadcrumbs(hasToolbar && !breadcrumbs);\n\n    const verticalOffsets = computeVerticalLayout({\n      topOffset: placement.insetBlockStart,\n      hasVisibleToolbar: hasToolbar && toolbarState !== 'hide',\n      notificationsHeight: notificationsHeight ?? 0,\n      toolbarHeight: toolbarHeight ?? 0,\n      stickyNotifications: resolvedStickyNotifications,\n    });\n\n    const appLayoutInternals: AppLayoutInternals = {\n      ariaLabels: ariaLabelsWithDrawers,\n      headerVariant,\n      isMobile,\n      breadcrumbs,\n      discoveredBreadcrumbs,\n      stickyNotifications: resolvedStickyNotifications,\n      navigationOpen: resolvedNavigationOpen,\n      navigation: resolvedNavigation,\n      navigationFocusControl,\n      activeDrawer,\n      activeDrawerSize,\n      minDrawerSize,\n      maxDrawerSize,\n      minGlobalDrawersSizes,\n      maxGlobalDrawersSizes,\n      drawers: drawers!,\n      globalDrawers,\n      activeGlobalDrawers,\n      activeGlobalDrawersIds,\n      activeGlobalDrawersSizes,\n      onActiveGlobalDrawersChange,\n      drawersFocusControl,\n      globalDrawersFocusControl,\n      splitPanelPosition,\n      splitPanelToggleConfig,\n      splitPanelOpen,\n      splitPanelControlId,\n      splitPanelFocusControl,\n      placement,\n      toolbarState,\n      setToolbarState,\n      verticalOffsets,\n      drawersOpenQueue,\n      setToolbarHeight,\n      setNotificationsHeight,\n      onSplitPanelToggle: onSplitPanelToggleHandler,\n      onNavigationToggle,\n      onActiveDrawerChange: onActiveDrawerChangeHandler,\n      onActiveDrawerResize,\n      splitPanelAnimationDisabled,\n      expandedDrawerId,\n      setExpandedDrawerId,\n    };\n\n    const splitPanelInternals: SplitPanelProviderProps = {\n      bottomOffset: 0,\n      getMaxHeight: () => {\n        const availableHeight =\n          document.documentElement.clientHeight - placement.insetBlockStart - placement.insetBlockEnd;\n        // If the page is likely zoomed in at 200%, allow the split panel to fill the content area.\n        return availableHeight < 400 ? availableHeight - 40 : availableHeight - 250;\n      },\n      maxWidth: maxSplitPanelSize,\n      isForcedPosition: splitPanelForcedPosition,\n      isOpen: splitPanelOpen,\n      leftOffset: 0,\n      onPreferencesChange: onSplitPanelPreferencesChangeHandler,\n      onResize: onSplitPanelResizeHandler,\n      onToggle: onSplitPanelToggleHandler,\n      position: splitPanelPosition,\n      reportSize: size => setSplitPanelReportedSize(size),\n      reportHeaderHeight: size => setSplitPanelHeaderBlockSize(size),\n      headerHeight: splitPanelHeaderBlockSize,\n      rightOffset: 0,\n      size: splitPanelSize,\n      topOffset: 0,\n      setSplitPanelToggle: setSplitPanelToggleConfig,\n      refs: splitPanelFocusControl.refs,\n    };\n\n    const closeFirstDrawer = useStableCallback(() => {\n      const drawerToClose = drawersOpenQueue[drawersOpenQueue.length - 1];\n      if (activeDrawer && activeDrawer?.id === drawerToClose) {\n        onActiveDrawerChange(null, { initiatedByUserAction: true });\n      } else if (activeGlobalDrawersIds.includes(drawerToClose)) {\n        onActiveGlobalDrawersChange(drawerToClose, { initiatedByUserAction: true });\n      }\n    });\n\n    useEffect(() => {\n      // Close navigation drawer on mobile so that the main content is visible\n      if (isMobile) {\n        onNavigationToggle(false);\n      }\n      // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, [isMobile]);\n\n    const getTotalActiveDrawersMinSize = () => {\n      const combinedDrawers = [...(drawers || []), ...globalDrawers];\n      let result = activeGlobalDrawersIds\n        .map(activeDrawerId =>\n          Math.min(\n            combinedDrawers.find(drawer => drawer.id === activeDrawerId)?.defaultSize ?? MIN_DRAWER_SIZE,\n            MIN_DRAWER_SIZE\n          )\n        )\n        .reduce((acc, curr) => acc + curr, 0);\n      if (activeDrawer) {\n        result += Math.min(activeDrawer?.defaultSize ?? MIN_DRAWER_SIZE, MIN_DRAWER_SIZE);\n      }\n\n      return result;\n    };\n\n    const totalActiveDrawersMinSize = getTotalActiveDrawersMinSize();\n\n    useEffect(() => {\n      if (isMobile) {\n        return;\n      }\n\n      const activeNavigationWidth = !navigationHide && navigationOpen ? navigationWidth : 0;\n      const scrollWidth = activeNavigationWidth + CONTENT_PADDING + totalActiveDrawersMinSize;\n      const hasHorizontalScroll = scrollWidth > placement.inlineSize;\n      if (hasHorizontalScroll) {\n        if (!navigationHide && navigationOpen) {\n          onNavigationToggle(false);\n          return;\n        }\n\n        closeFirstDrawer();\n      }\n    }, [\n      totalActiveDrawersMinSize,\n      closeFirstDrawer,\n      isMobile,\n      navigationHide,\n      navigationOpen,\n      navigationWidth,\n      onNavigationToggle,\n      placement.inlineSize,\n    ]);\n\n    /**\n     * Returns true if the AppLayout is nested\n     * Does not apply to iframe\n     */\n    const getIsNestedInAppLayout = (element: HTMLElement | null): boolean => {\n      let currentElement: Element | null = element?.parentElement ?? null;\n\n      // this traverse is needed only for JSDOM\n      // in real browsers the globalVar will be propagated to all descendants and this loops exits after initial iteration\n      while (currentElement) {\n        if (getComputedStyle(currentElement).getPropertyValue(globalVars.stickyVerticalTopOffset)) {\n          return true;\n        }\n        currentElement = currentElement.parentElement;\n      }\n\n      return false;\n    };\n\n    useLayoutEffect(() => {\n      if (!hasToolbar) {\n        setIsNested(getIsNestedInAppLayout(rootRef.current));\n      }\n    }, [hasToolbar]);\n\n    const splitPanelOffsets = computeSplitPanelOffsets({\n      placement,\n      hasSplitPanel: !!splitPanel,\n      splitPanelOpen,\n      splitPanelPosition,\n      splitPanelFullHeight: splitPanelReportedSize,\n      splitPanelHeaderHeight: splitPanelHeaderBlockSize,\n    });\n\n    return (\n      <AppLayoutVisibilityContext.Provider value={isIntersecting}>\n        {/* Rendering a hidden copy of breadcrumbs to trigger their deduplication */}\n        {!hasToolbar && breadcrumbs ? <ScreenreaderOnly>{breadcrumbs}</ScreenreaderOnly> : null}\n        <SkeletonLayout\n          ref={useMergeRefs(intersectionObserverRef, rootRef)}\n          isNested={isNested}\n          // Why not use drawerExpandedMode={!!expandedDrawerId || !!toolbarProps?.expandedDrawerId} instead?\n          // Because in nested layouts, the parent layout hides its main content area,\n          // which means the child layout isn't rendered at all in that case\n          drawerExpandedModeInChildLayout={!!toolbarProps?.expandedDrawerId}\n          drawerExpandedMode={!!expandedDrawerId}\n          style={{\n            paddingBlockEnd: splitPanelOffsets.mainContentPaddingBlockEnd,\n            ...(hasToolbar || !isNested\n              ? {\n                  [globalVars.stickyVerticalTopOffset]: `${verticalOffsets.header}px`,\n                  [globalVars.stickyVerticalBottomOffset]: `${splitPanelOffsets.stickyVerticalBottomOffset}px`,\n                }\n              : {}),\n            ...(!isMobile ? { minWidth: `${minContentWidth}px` } : {}),\n          }}\n          toolbar={\n            hasToolbar && <AppLayoutToolbar appLayoutInternals={appLayoutInternals} toolbarProps={toolbarProps} />\n          }\n          notifications={\n            notifications && (\n              <AppLayoutNotifications appLayoutInternals={appLayoutInternals}>{notifications}</AppLayoutNotifications>\n            )\n          }\n          headerVariant={headerVariant}\n          contentHeader={contentHeader}\n          // delay rendering the content until registration of this instance is complete\n          content={registered ? content : null}\n          navigation={resolvedNavigation && <AppLayoutNavigation appLayoutInternals={appLayoutInternals} />}\n          navigationOpen={resolvedNavigationOpen}\n          navigationWidth={navigationWidth}\n          navigationAnimationDisabled={navigationAnimationDisabled}\n          tools={drawers && drawers.length > 0 && <AppLayoutDrawer appLayoutInternals={appLayoutInternals} />}\n          globalTools={\n            <ActiveDrawersContext.Provider value={activeGlobalDrawersIds}>\n              <AppLayoutGlobalDrawers appLayoutInternals={appLayoutInternals} />\n            </ActiveDrawersContext.Provider>\n          }\n          globalToolsOpen={!!activeGlobalDrawersIds.length}\n          toolsOpen={!!activeDrawer}\n          toolsWidth={activeDrawerSize}\n          sideSplitPanel={\n            splitPanelPosition === 'side' && (\n              <AppLayoutSplitPanelSide\n                appLayoutInternals={appLayoutInternals}\n                splitPanelInternals={splitPanelInternals}\n              >\n                {splitPanel}\n              </AppLayoutSplitPanelSide>\n            )\n          }\n          bottomSplitPanel={\n            splitPanelPosition === 'bottom' && (\n              <AppLayoutSplitPanelBottom\n                appLayoutInternals={appLayoutInternals}\n                splitPanelInternals={splitPanelInternals}\n              >\n                {splitPanel}\n              </AppLayoutSplitPanelBottom>\n            )\n          }\n          splitPanelOpen={splitPanelOpen}\n          placement={placement}\n          contentType={contentType}\n          maxContentWidth={maxContentWidth}\n          disableContentPaddings={disableContentPaddings}\n        />\n      </AppLayoutVisibilityContext.Provider>\n    );\n  }\n);\n\nexport default AppLayoutVisualRefreshToolbar;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}