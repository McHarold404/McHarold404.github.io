{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { createContext, useCallback, useEffect, useLayoutEffect, useState } from 'react';\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\nimport * as tokens from '../internal/generated/styles/tokens';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport globalVars from '../internal/styles/global-vars';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\nexport function computeOffset(_ref) {\n  let {\n    isMobile,\n    __stickyOffset,\n    __mobileStickyOffset,\n    hasInnerOverflowParents,\n    __additionalOffset\n  } = _ref;\n  const localOffset = isMobile ? (__stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0) - (__mobileStickyOffset !== null && __mobileStickyOffset !== void 0 ? __mobileStickyOffset : 0) : __stickyOffset !== null && __stickyOffset !== void 0 ? __stickyOffset : 0;\n  if (hasInnerOverflowParents || __stickyOffset !== undefined) {\n    return `${localOffset}px`;\n  }\n  const globalOffset = `var(${globalVars.stickyVerticalTopOffset}, 0px)`;\n  return `calc(${globalOffset} + ${localOffset}px + ${__additionalOffset ? tokens.spaceScaledS : '0px'})`;\n}\nexport const StickyHeaderContext = createContext({\n  isStuck: false,\n  isStuckAtBottom: false\n});\nexport const useStickyHeader = function (rootRef, headerRef, __stickyHeader, __stickyOffset, __mobileStickyOffset, __disableMobile) {\n  let __additionalOffset = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : false;\n  const isMobile = useMobile();\n  const disableSticky = isMobile && __disableMobile;\n  const isSticky = !disableSticky && !!__stickyHeader;\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  const [isStuckAtBottom, setIsStuckAtBottom] = useState(false);\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n  const computedOffset = computeOffset({\n    isMobile,\n    __stickyOffset,\n    __mobileStickyOffset,\n    hasInnerOverflowParents,\n    __additionalOffset\n  });\n  const stickyStyles = isSticky ? {\n    style: {\n      top: computedOffset\n    }\n  } : {};\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(_ref2 => {\n    let {\n      isTrusted,\n      target,\n      type\n    } = _ref2;\n    if (type === 'resize' && target === window && !isTrusted) {\n      // The window size didn't actually change, it was a synthetic event\n      return;\n    }\n    if (rootRef.current && headerRef.current) {\n      const rootTopBorderWidth = parseFloat(getComputedStyle(rootRef.current).borderTopWidth) || 0;\n      // Using Math.round to adjust for rounding errors in floating-point arithmetic and timing issues\n      const rootTop = Math.round(rootRef.current.getBoundingClientRect().top + rootTopBorderWidth);\n      const headerTop = Math.round(headerRef.current.getBoundingClientRect().top);\n      if (rootTop < headerTop) {\n        setIsStuck(true);\n      } else {\n        setIsStuck(false);\n      }\n      const rootBottom = Math.round(rootRef.current.getBoundingClientRect().bottom - rootTopBorderWidth);\n      const headerBottom = Math.round(headerRef.current.getBoundingClientRect().bottom);\n      if (rootBottom <= headerBottom) {\n        setIsStuckAtBottom(true);\n      } else {\n        setIsStuckAtBottom(false);\n      }\n    }\n  }, [rootRef, headerRef]);\n  useEffect(() => {\n    if (isSticky) {\n      const controller = new AbortController();\n      window.addEventListener('scroll', checkIfStuck, {\n        capture: true,\n        signal: controller.signal\n      });\n      window.addEventListener('resize', checkIfStuck, {\n        signal: controller.signal\n      });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    isStuckAtBottom,\n    stickyStyles\n  };\n};","map":{"version":3,"names":["createContext","useCallback","useEffect","useLayoutEffect","useState","findUpUntil","tokens","useMobile","globalVars","getOverflowParents","computeOffset","_ref","isMobile","__stickyOffset","__mobileStickyOffset","hasInnerOverflowParents","__additionalOffset","localOffset","undefined","globalOffset","stickyVerticalTopOffset","spaceScaledS","StickyHeaderContext","isStuck","isStuckAtBottom","useStickyHeader","rootRef","headerRef","__stickyHeader","__disableMobile","arguments","length","disableSticky","isSticky","setHasInnerOverflowParents","setIsStuck","setIsStuckAtBottom","current","overflowParents","mainElement","elem","tagName","computedOffset","stickyStyles","style","top","checkIfStuck","_ref2","isTrusted","target","type","window","rootTopBorderWidth","parseFloat","getComputedStyle","borderTopWidth","rootTop","Math","round","getBoundingClientRect","headerTop","rootBottom","bottom","headerBottom","controller","AbortController","addEventListener","capture","signal","abort"],"sources":["/Users/naman/Desktop/Portfolio/react-portfolio/node_modules/src/container/use-sticky-header.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { createContext, RefObject, useCallback, useEffect, useLayoutEffect, useState } from 'react';\n\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\n\nimport * as tokens from '../internal/generated/styles/tokens';\nimport { useMobile } from '../internal/hooks/use-mobile';\nimport globalVars from '../internal/styles/global-vars';\nimport { getOverflowParents } from '../internal/utils/scrollable-containers';\n\ninterface StickyHeaderContextProps {\n  isStuck: boolean;\n  isStuckAtBottom: boolean;\n}\n\ninterface ComputeOffsetProps {\n  isMobile: boolean;\n  __stickyOffset?: number;\n  __mobileStickyOffset?: number;\n  hasInnerOverflowParents: boolean;\n  __additionalOffset?: boolean;\n}\n\nexport function computeOffset({\n  isMobile,\n  __stickyOffset,\n  __mobileStickyOffset,\n  hasInnerOverflowParents,\n  __additionalOffset,\n}: ComputeOffsetProps): string {\n  const localOffset = isMobile ? (__stickyOffset ?? 0) - (__mobileStickyOffset ?? 0) : (__stickyOffset ?? 0);\n  if (hasInnerOverflowParents || __stickyOffset !== undefined) {\n    return `${localOffset}px`;\n  }\n  const globalOffset = `var(${globalVars.stickyVerticalTopOffset}, 0px)`;\n\n  return `calc(${globalOffset} + ${localOffset}px + ${__additionalOffset ? tokens.spaceScaledS : '0px'})`;\n}\n\nexport const StickyHeaderContext = createContext<StickyHeaderContextProps>({\n  isStuck: false,\n  isStuckAtBottom: false,\n});\n\nexport const useStickyHeader = (\n  rootRef: RefObject<HTMLDivElement>,\n  headerRef: RefObject<HTMLDivElement>,\n  __stickyHeader?: boolean,\n  __stickyOffset?: number,\n  __mobileStickyOffset?: number,\n  __disableMobile?: boolean,\n  __additionalOffset = false\n) => {\n  const isMobile = useMobile();\n  const disableSticky = isMobile && __disableMobile;\n  const isSticky = !disableSticky && !!__stickyHeader;\n\n  // If it has overflow parents inside the app layout, we shouldn't apply a sticky offset.\n  const [hasInnerOverflowParents, setHasInnerOverflowParents] = useState(false);\n  const [isStuck, setIsStuck] = useState(false);\n  const [isStuckAtBottom, setIsStuckAtBottom] = useState(false);\n\n  useLayoutEffect(() => {\n    if (rootRef.current) {\n      const overflowParents = getOverflowParents(rootRef.current);\n      const mainElement = findUpUntil(rootRef.current, elem => elem.tagName === 'MAIN');\n\n      // In both versions of the app layout, the scrolling element for disableBodyScroll\n      // is the <main>. If the closest overflow parent is also the closest <main> and we have\n      // offset values, it's safe to assume that it's the app layout scroll root and we\n      // should stop there.\n      setHasInnerOverflowParents(overflowParents.length > 0 && overflowParents[0] !== mainElement);\n    }\n  }, [rootRef]);\n\n  const computedOffset = computeOffset({\n    isMobile,\n    __stickyOffset,\n    __mobileStickyOffset,\n    hasInnerOverflowParents,\n    __additionalOffset,\n  });\n\n  const stickyStyles = isSticky\n    ? {\n        style: {\n          top: computedOffset,\n        },\n      }\n    : {};\n\n  // \"stuck\" state, when the header has moved from its original posititon has a\n  // box-shadow, applied here by a \"header-stuck\" className\n  const checkIfStuck = useCallback(\n    ({ isTrusted, target, type }) => {\n      if (type === 'resize' && target === window && !isTrusted) {\n        // The window size didn't actually change, it was a synthetic event\n        return;\n      }\n      if (rootRef.current && headerRef.current) {\n        const rootTopBorderWidth = parseFloat(getComputedStyle(rootRef.current).borderTopWidth) || 0;\n\n        // Using Math.round to adjust for rounding errors in floating-point arithmetic and timing issues\n        const rootTop = Math.round(rootRef.current.getBoundingClientRect().top + rootTopBorderWidth);\n        const headerTop = Math.round(headerRef.current.getBoundingClientRect().top);\n        if (rootTop < headerTop) {\n          setIsStuck(true);\n        } else {\n          setIsStuck(false);\n        }\n\n        const rootBottom = Math.round(rootRef.current.getBoundingClientRect().bottom - rootTopBorderWidth);\n        const headerBottom = Math.round(headerRef.current.getBoundingClientRect().bottom);\n        if (rootBottom <= headerBottom) {\n          setIsStuckAtBottom(true);\n        } else {\n          setIsStuckAtBottom(false);\n        }\n      }\n    },\n    [rootRef, headerRef]\n  );\n\n  useEffect(() => {\n    if (isSticky) {\n      const controller = new AbortController();\n      window.addEventListener('scroll', checkIfStuck, { capture: true, signal: controller.signal });\n      window.addEventListener('resize', checkIfStuck, { signal: controller.signal });\n      return () => {\n        controller.abort();\n      };\n    }\n  }, [isSticky, checkIfStuck]);\n  return {\n    isSticky,\n    isStuck,\n    isStuckAtBottom,\n    stickyStyles,\n  };\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}