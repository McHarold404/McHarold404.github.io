{"ast":null,"code":"import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';\nimport { warnOnce } from '../logging.js';\nconst filterUsingOperator = (itemValue, _ref) => {\n  let {\n    tokenValue,\n    operator: {\n      operator,\n      match,\n      tokenType\n    }\n  } = _ref;\n  // For match=\"date\" or match=\"datetime\" we expect the value to be a Date object.\n  // The token value is expected to be an ISO date- or datetime string, example:\n  // match(operator=\"=\", token=\"2020-01-01\", value=new Date(\"2020-01-01\")) == true\n  if (match === 'date' || match === 'datetime') {\n    return matchDateValue({\n      tokenValue,\n      itemValue,\n      operator,\n      match\n    });\n  }\n  // For custom match functions there is no expectation to value or token type: the function is supposed\n  // to handle everything. It is recommended to treat both the token and the value as unknowns.\n  else if (typeof match === 'function') {\n    return match(itemValue, tokenValue);\n  } else if (match) {\n    throw new Error('Unsupported `operator.match` type given.');\n  }\n  // For default matching logic we expect the value to be a primitive type or an object that matches by reference.\n  // The token can be an array (tokenType=\"enum\") or a value (tokenType=\"value\" or tokenType=undefined), examples:\n  // match(operator=\"=\", token=\"A\", value=\"A\") == true\n  // match(operator=\"=\", token=[\"A\", \"B\"], value=\"A\") == true\n  return matchPrimitiveValue({\n    tokenValue,\n    itemValue,\n    operator,\n    tokenType\n  });\n};\nfunction matchDateValue(_ref2) {\n  let {\n    tokenValue,\n    itemValue,\n    operator,\n    match\n  } = _ref2;\n  const comparator = match === 'date' ? compareDates : compareTimestamps;\n  const comparisonResult = comparator(itemValue, tokenValue);\n  switch (operator) {\n    case '<':\n      return comparisonResult < 0;\n    case '<=':\n      return comparisonResult <= 0;\n    case '>':\n      return comparisonResult > 0;\n    case '>=':\n      return comparisonResult >= 0;\n    case '=':\n      return comparisonResult === 0;\n    case '!=':\n      return comparisonResult !== 0;\n    default:\n      warnOnce(`Unsupported operator \"${operator}\" given for match=\"${match}\".`);\n      return false;\n  }\n}\nfunction matchPrimitiveValue(_ref3) {\n  let {\n    tokenValue,\n    itemValue,\n    operator,\n    tokenType\n  } = _ref3;\n  if (tokenType === 'enum') {\n    if (!tokenValue || !Array.isArray(tokenValue)) {\n      warnOnce('The token value must be an array when tokenType==\"enum\".');\n      return false;\n    }\n    switch (operator) {\n      case '=':\n        return tokenValue && tokenValue.includes(itemValue);\n      case '!=':\n        return !tokenValue || !tokenValue.includes(itemValue);\n      default:\n        warnOnce(`Unsupported operator \"${operator}\" given for tokenType==\"enum\".`);\n        return false;\n    }\n  }\n  switch (operator) {\n    case '<':\n      return itemValue < tokenValue;\n    case '<=':\n      return itemValue <= tokenValue;\n    case '>':\n      return itemValue > tokenValue;\n    case '>=':\n      return itemValue >= tokenValue;\n    case '=':\n      // eslint-disable-next-line eqeqeq\n      return itemValue == tokenValue;\n    case '!=':\n      // eslint-disable-next-line eqeqeq\n      return itemValue != tokenValue;\n    case ':':\n      return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;\n    case '!:':\n      return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;\n    case '^':\n      return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n    case '!^':\n      return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n    // The unsupported operators result in an exception being thrown.\n    // The exception can be avoided if using the match function.\n    default:\n      throw new Error('Unsupported operator given.');\n  }\n}\nfunction freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {\n  // If the operator is not a negation, we just need one property of the object to match.\n  // If the operator is a negation, we want none of the properties of the object to match.\n  const isNegation = operator.startsWith('!');\n  return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](propertyKey => {\n    const {\n      operators\n    } = filteringPropertiesMap[propertyKey];\n    const propertyOperator = operators[operator];\n    if (!propertyOperator) {\n      return isNegation;\n    }\n    return filterUsingOperator(item[propertyKey], {\n      tokenValue,\n      operator: propertyOperator\n    });\n  });\n}\nfunction filterByToken(token, item, filteringPropertiesMap) {\n  if (token.propertyKey) {\n    // token refers to a unknown property or uses an unsupported operator\n    if (!(token.propertyKey in filteringPropertiesMap) || !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {\n      return false;\n    }\n    const property = filteringPropertiesMap[token.propertyKey];\n    const operator = property.operators[token.operator];\n    const itemValue = (operator === null || operator === void 0 ? void 0 : operator.match) ? item[token.propertyKey] : fixupFalsyValues(item[token.propertyKey]);\n    return filterUsingOperator(itemValue, {\n      tokenValue: token.value,\n      operator: operator !== null && operator !== void 0 ? operator : {\n        operator: token.operator\n      }\n    });\n  }\n  return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);\n}\nfunction defaultFilteringFunction(filteringPropertiesMap) {\n  return (item, query) => {\n    var _a;\n    function evaluate(tokenOrGroup) {\n      if ('operation' in tokenOrGroup) {\n        let result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;\n        for (const group of tokenOrGroup.tokens) {\n          result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);\n        }\n        return result;\n      } else {\n        return filterByToken(tokenOrGroup, item, filteringPropertiesMap);\n      }\n    }\n    return evaluate({\n      operation: query.operation,\n      tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens\n    });\n  };\n}\nexport function createPropertyFilterPredicate(propertyFiltering) {\n  let query = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n    tokens: [],\n    operation: 'and'\n  };\n  if (!propertyFiltering) {\n    return null;\n  }\n  const filteringPropertiesMap = propertyFiltering.filteringProperties.reduce((acc, _ref4) => {\n    let {\n      key,\n      operators,\n      defaultOperator\n    } = _ref4;\n    const operatorMap = {\n      [defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=']: {\n        operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '='\n      }\n    };\n    operators === null || operators === void 0 ? void 0 : operators.forEach(op => {\n      if (typeof op === 'string') {\n        operatorMap[op] = {\n          operator: op\n        };\n      } else {\n        operatorMap[op.operator] = {\n          operator: op.operator,\n          match: op.match,\n          tokenType: op.tokenType\n        };\n      }\n    });\n    acc[key] = {\n      operators: operatorMap\n    };\n    return acc;\n  }, {});\n  const filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);\n  return item => filteringFunction(item, query);\n}\nexport const fixupFalsyValues = value => {\n  if (typeof value === 'boolean') {\n    return value + '';\n  }\n  if (value || value === 0) {\n    return value;\n  }\n  return '';\n};","map":{"version":3,"names":["compareDates","compareTimestamps","warnOnce","filterUsingOperator","itemValue","_ref","tokenValue","operator","match","tokenType","matchDateValue","Error","matchPrimitiveValue","_ref2","comparator","comparisonResult","_ref3","Array","isArray","includes","toLowerCase","indexOf","startsWith","freeTextFilter","item","filteringPropertiesMap","isNegation","Object","keys","propertyKey","operators","propertyOperator","filterByToken","token","property","fixupFalsyValues","value","defaultFilteringFunction","query","_a","evaluate","tokenOrGroup","result","operation","tokens","length","group","tokenGroups","createPropertyFilterPredicate","propertyFiltering","arguments","undefined","filteringProperties","reduce","acc","_ref4","key","defaultOperator","operatorMap","forEach","op","filteringFunction"],"sources":["/Users/naman/Desktop/Portfolio/react-portfolio/node_modules/@cloudscape-design/collection-hooks/mjs/operations/property-filter.js"],"sourcesContent":["import { compareDates, compareTimestamps } from '../date-utils/compare-dates.js';\nimport { warnOnce } from '../logging.js';\nconst filterUsingOperator = (itemValue, { tokenValue, operator: { operator, match, tokenType }, }) => {\n    // For match=\"date\" or match=\"datetime\" we expect the value to be a Date object.\n    // The token value is expected to be an ISO date- or datetime string, example:\n    // match(operator=\"=\", token=\"2020-01-01\", value=new Date(\"2020-01-01\")) == true\n    if (match === 'date' || match === 'datetime') {\n        return matchDateValue({ tokenValue, itemValue, operator, match });\n    }\n    // For custom match functions there is no expectation to value or token type: the function is supposed\n    // to handle everything. It is recommended to treat both the token and the value as unknowns.\n    else if (typeof match === 'function') {\n        return match(itemValue, tokenValue);\n    }\n    else if (match) {\n        throw new Error('Unsupported `operator.match` type given.');\n    }\n    // For default matching logic we expect the value to be a primitive type or an object that matches by reference.\n    // The token can be an array (tokenType=\"enum\") or a value (tokenType=\"value\" or tokenType=undefined), examples:\n    // match(operator=\"=\", token=\"A\", value=\"A\") == true\n    // match(operator=\"=\", token=[\"A\", \"B\"], value=\"A\") == true\n    return matchPrimitiveValue({ tokenValue, itemValue, operator, tokenType });\n};\nfunction matchDateValue({ tokenValue, itemValue, operator, match, }) {\n    const comparator = match === 'date' ? compareDates : compareTimestamps;\n    const comparisonResult = comparator(itemValue, tokenValue);\n    switch (operator) {\n        case '<':\n            return comparisonResult < 0;\n        case '<=':\n            return comparisonResult <= 0;\n        case '>':\n            return comparisonResult > 0;\n        case '>=':\n            return comparisonResult >= 0;\n        case '=':\n            return comparisonResult === 0;\n        case '!=':\n            return comparisonResult !== 0;\n        default:\n            warnOnce(`Unsupported operator \"${operator}\" given for match=\"${match}\".`);\n            return false;\n    }\n}\nfunction matchPrimitiveValue({ tokenValue, itemValue, operator, tokenType, }) {\n    if (tokenType === 'enum') {\n        if (!tokenValue || !Array.isArray(tokenValue)) {\n            warnOnce('The token value must be an array when tokenType==\"enum\".');\n            return false;\n        }\n        switch (operator) {\n            case '=':\n                return tokenValue && tokenValue.includes(itemValue);\n            case '!=':\n                return !tokenValue || !tokenValue.includes(itemValue);\n            default:\n                warnOnce(`Unsupported operator \"${operator}\" given for tokenType==\"enum\".`);\n                return false;\n        }\n    }\n    switch (operator) {\n        case '<':\n            return itemValue < tokenValue;\n        case '<=':\n            return itemValue <= tokenValue;\n        case '>':\n            return itemValue > tokenValue;\n        case '>=':\n            return itemValue >= tokenValue;\n        case '=':\n            // eslint-disable-next-line eqeqeq\n            return itemValue == tokenValue;\n        case '!=':\n            // eslint-disable-next-line eqeqeq\n            return itemValue != tokenValue;\n        case ':':\n            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) > -1;\n        case '!:':\n            return (itemValue + '').toLowerCase().indexOf((tokenValue + '').toLowerCase()) === -1;\n        case '^':\n            return (itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n        case '!^':\n            return !(itemValue + '').toLowerCase().startsWith((tokenValue + '').toLowerCase());\n        // The unsupported operators result in an exception being thrown.\n        // The exception can be avoided if using the match function.\n        default:\n            throw new Error('Unsupported operator given.');\n    }\n}\nfunction freeTextFilter(tokenValue, item, operator, filteringPropertiesMap) {\n    // If the operator is not a negation, we just need one property of the object to match.\n    // If the operator is a negation, we want none of the properties of the object to match.\n    const isNegation = operator.startsWith('!');\n    return Object.keys(filteringPropertiesMap)[isNegation ? 'every' : 'some'](propertyKey => {\n        const { operators } = filteringPropertiesMap[propertyKey];\n        const propertyOperator = operators[operator];\n        if (!propertyOperator) {\n            return isNegation;\n        }\n        return filterUsingOperator(item[propertyKey], { tokenValue, operator: propertyOperator });\n    });\n}\nfunction filterByToken(token, item, filteringPropertiesMap) {\n    if (token.propertyKey) {\n        // token refers to a unknown property or uses an unsupported operator\n        if (!(token.propertyKey in filteringPropertiesMap) ||\n            !(token.operator in filteringPropertiesMap[token.propertyKey].operators)) {\n            return false;\n        }\n        const property = filteringPropertiesMap[token.propertyKey];\n        const operator = property.operators[token.operator];\n        const itemValue = (operator === null || operator === void 0 ? void 0 : operator.match)\n            ? item[token.propertyKey]\n            : fixupFalsyValues(item[token.propertyKey]);\n        return filterUsingOperator(itemValue, {\n            tokenValue: token.value,\n            operator: operator !== null && operator !== void 0 ? operator : { operator: token.operator },\n        });\n    }\n    return freeTextFilter(token.value, item, token.operator, filteringPropertiesMap);\n}\nfunction defaultFilteringFunction(filteringPropertiesMap) {\n    return (item, query) => {\n        var _a;\n        function evaluate(tokenOrGroup) {\n            if ('operation' in tokenOrGroup) {\n                let result = tokenOrGroup.operation === 'and' ? true : !tokenOrGroup.tokens.length;\n                for (const group of tokenOrGroup.tokens) {\n                    result = tokenOrGroup.operation === 'and' ? result && evaluate(group) : result || evaluate(group);\n                }\n                return result;\n            }\n            else {\n                return filterByToken(tokenOrGroup, item, filteringPropertiesMap);\n            }\n        }\n        return evaluate({\n            operation: query.operation,\n            tokens: (_a = query.tokenGroups) !== null && _a !== void 0 ? _a : query.tokens,\n        });\n    };\n}\nexport function createPropertyFilterPredicate(propertyFiltering, query = { tokens: [], operation: 'and' }) {\n    if (!propertyFiltering) {\n        return null;\n    }\n    const filteringPropertiesMap = propertyFiltering.filteringProperties.reduce((acc, { key, operators, defaultOperator }) => {\n        const operatorMap = { [defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=']: { operator: defaultOperator !== null && defaultOperator !== void 0 ? defaultOperator : '=' } };\n        operators === null || operators === void 0 ? void 0 : operators.forEach(op => {\n            if (typeof op === 'string') {\n                operatorMap[op] = { operator: op };\n            }\n            else {\n                operatorMap[op.operator] = { operator: op.operator, match: op.match, tokenType: op.tokenType };\n            }\n        });\n        acc[key] = { operators: operatorMap };\n        return acc;\n    }, {});\n    const filteringFunction = propertyFiltering.filteringFunction || defaultFilteringFunction(filteringPropertiesMap);\n    return item => filteringFunction(item, query);\n}\nexport const fixupFalsyValues = (value) => {\n    if (typeof value === 'boolean') {\n        return value + '';\n    }\n    if (value || value === 0) {\n        return value;\n    }\n    return '';\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}