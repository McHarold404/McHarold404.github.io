{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useRef, useState } from 'react';\nimport { closestCenter, PointerSensor, useSensor, useSensors } from '@dnd-kit/core';\nimport { hasSortableData } from '@dnd-kit/sortable';\nimport { KeyboardSensor } from './keyboard-sensor';\nvar KeyboardCode;\n(function (KeyboardCode) {\n  KeyboardCode[\"Space\"] = \"Space\";\n  KeyboardCode[\"Down\"] = \"ArrowDown\";\n  KeyboardCode[\"Right\"] = \"ArrowRight\";\n  KeyboardCode[\"Left\"] = \"ArrowLeft\";\n  KeyboardCode[\"Up\"] = \"ArrowUp\";\n  KeyboardCode[\"Esc\"] = \"Escape\";\n  KeyboardCode[\"Enter\"] = \"Enter\";\n})(KeyboardCode || (KeyboardCode = {}));\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\nexport default function useDragAndDropReorder(_ref) {\n  let {\n    items,\n    itemDefinition\n  } = _ref;\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState(null);\n  const setActiveItem = id => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n  const handleKeyDown = event => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex = items.findIndex(item => itemDefinition.id(item) === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < items.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n  const getClosestId = active => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = items.findIndex(item => itemDefinition.id(item) === active.id);\n    const newIndex = Math.max(0, Math.min(items.length - 1, currentIndex + positionDelta.current));\n    return itemDefinition.id(items[newIndex]);\n  };\n  const collisionDetection = _ref2 => {\n    let {\n      active,\n      collisionRect,\n      droppableContainers,\n      droppableRects,\n      pointerCoordinates\n    } = _ref2;\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers,\n        pointerCoordinates\n      });\n    }\n  };\n  const coordinateGetter = (event, _ref3) => {\n    let {\n      context: {\n        active,\n        collisionRect,\n        droppableRects,\n        droppableContainers\n      }\n    } = _ref3;\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n      if (!active || !collisionRect) {\n        return;\n      }\n      const closestId = getClosestId(active);\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable === null || newDroppable === void 0 ? void 0 : newDroppable.node.current;\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top\n          };\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y\n          };\n        }\n      }\n    }\n  };\n  const sensors = useSensors(useSensor(PointerSensor), useSensor(KeyboardSensor, {\n    coordinateGetter,\n    onActivation: () => {\n      isKeyboard.current = true;\n    }\n  }));\n  return {\n    activeItemId,\n    setActiveItemId: setActiveItem,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors\n  };\n}\nfunction isAfter(a, b) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\nfunction getCollidingContainer(_ref4) {\n  let {\n    activeId,\n    closestId,\n    droppableContainers\n  } = _ref4;\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(_ref5 => {\n    let {\n      id\n    } = _ref5;\n    return id === closestId;\n  });\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0\n      }\n    };\n  }\n}\nconst isEscape = key => key === 'Escape' || key === 'Esc';","map":{"version":3,"names":["useRef","useState","closestCenter","PointerSensor","useSensor","useSensors","hasSortableData","KeyboardSensor","KeyboardCode","useDragAndDropReorder","_ref","items","itemDefinition","isKeyboard","positionDelta","activeItemId","setActiveItemId","setActiveItem","id","current","handleKeyDown","event","currentTargetIndex","findIndex","item","key","length","isEscape","stopPropagation","getClosestId","active","currentIndex","newIndex","Math","max","min","collisionDetection","_ref2","collisionRect","droppableContainers","droppableRects","pointerCoordinates","collidingContainer","getCollidingContainer","activeId","closestId","coordinateGetter","_ref3","context","code","Up","Down","preventDefault","activeDroppable","get","newDroppable","newRect","newNode","node","isAfterActive","isAfter","offset","x","width","y","height","rectCoordinates","left","top","sensors","onActivation","a","b","data","sortable","index","_ref4","find","_ref5","droppableContainer","value"],"sources":["/Users/naman/Desktop/Portfolio/react-portfolio/node_modules/src/internal/components/sortable-area/use-drag-and-drop-reorder.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useRef, useState } from 'react';\nimport {\n  Active,\n  closestCenter,\n  CollisionDetection,\n  DroppableContainer,\n  KeyboardCoordinateGetter,\n  PointerSensor,\n  UniqueIdentifier,\n  useSensor,\n  useSensors,\n} from '@dnd-kit/core';\nimport { hasSortableData } from '@dnd-kit/sortable';\n\nimport { SortableAreaProps } from './interfaces';\nimport { KeyboardSensor } from './keyboard-sensor';\n\nenum KeyboardCode {\n  Space = 'Space',\n  Down = 'ArrowDown',\n  Right = 'ArrowRight',\n  Left = 'ArrowLeft',\n  Up = 'ArrowUp',\n  Esc = 'Escape',\n  Enter = 'Enter',\n}\n\n// A custom collision detection algorithm is used when using a keyboard to\n// work around an unexpected behavior when reordering items of variable height\n// with the keyboard.\n\n// Neither closestCenter nor closestCorners work really well for this case,\n// because the center (or corners) of a tall rectangle might be so low that it\n// is detected as being closest to the rectangle below of the one it should\n// actually swap with.\n\n// Instead of relying on coordinates, the expected results are achieved by\n// moving X positions up or down in the initially sorted array, depending on\n// the desired direction.\n\n// We let our collisionDetection and customCoordinateGetter use the same\n// getClosestId function which takes its value from the current component\n// state, to make sure they are always in sync.\n\nexport default function useDragAndDropReorder<Item>({\n  items,\n  itemDefinition,\n}: {\n  items: readonly Item[];\n  itemDefinition: SortableAreaProps.ItemDefinition<Item>;\n}) {\n  const isKeyboard = useRef(false);\n  const positionDelta = useRef(0);\n  const [activeItemId, setActiveItemId] = useState<UniqueIdentifier | null>(null);\n\n  const setActiveItem = (id: UniqueIdentifier | null) => {\n    setActiveItemId(id);\n    if (!id) {\n      isKeyboard.current = false;\n      positionDelta.current = 0;\n    }\n  };\n\n  const handleKeyDown = (event: React.KeyboardEvent) => {\n    if (isKeyboard.current && activeItemId) {\n      const currentTargetIndex =\n        items.findIndex(item => itemDefinition.id(item) === activeItemId) + positionDelta.current;\n      if (event.key === 'ArrowDown' && currentTargetIndex < items.length - 1) {\n        positionDelta.current += 1;\n      } else if (event.key === 'ArrowUp' && currentTargetIndex > 0) {\n        positionDelta.current -= 1;\n      }\n    }\n    if (activeItemId && isEscape(event.key)) {\n      // Prevent modal from closing when pressing Esc to cancel the dragging action\n      event.stopPropagation();\n    }\n  };\n\n  const getClosestId = (active: Active) => {\n    if (positionDelta.current === 0) {\n      return active.id;\n    }\n    const currentIndex = items.findIndex(item => itemDefinition.id(item) === active.id);\n    const newIndex = Math.max(0, Math.min(items.length - 1, currentIndex + positionDelta.current));\n    return itemDefinition.id(items[newIndex]);\n  };\n\n  const collisionDetection: CollisionDetection = ({\n    active,\n    collisionRect,\n    droppableContainers,\n    droppableRects,\n    pointerCoordinates,\n  }) => {\n    if (isKeyboard.current) {\n      // For keyboard interaction, determine the colliding container based on the movements made by the arrow keys,\n      // via getClosestId\n      const collidingContainer = getCollidingContainer({\n        activeId: active.id,\n        closestId: getClosestId(active),\n        droppableContainers,\n      });\n      return collidingContainer ? [collidingContainer] : [];\n    } else {\n      // For mouse interaction, use the closest center algorithm\n      return closestCenter({ active, collisionRect, droppableRects, droppableContainers, pointerCoordinates });\n    }\n  };\n\n  const coordinateGetter: KeyboardCoordinateGetter = (\n    event,\n    { context: { active, collisionRect, droppableRects, droppableContainers } }\n  ) => {\n    if (event.code === KeyboardCode.Up || event.code === KeyboardCode.Down) {\n      event.preventDefault();\n\n      if (!active || !collisionRect) {\n        return;\n      }\n\n      const closestId = getClosestId(active);\n\n      if (closestId !== null) {\n        const activeDroppable = droppableContainers.get(active.id);\n        const newDroppable = droppableContainers.get(closestId);\n        const newRect = newDroppable ? droppableRects.get(newDroppable.id) : null;\n        const newNode = newDroppable?.node.current;\n\n        if (newNode && newRect && activeDroppable && newDroppable) {\n          const isAfterActive = isAfter(activeDroppable, newDroppable);\n          const offset = {\n            x: isAfterActive ? collisionRect.width - newRect.width : 0,\n            y: isAfterActive ? collisionRect.height - newRect.height : 0,\n          };\n          const rectCoordinates = {\n            x: newRect.left,\n            y: newRect.top,\n          };\n\n          return {\n            x: rectCoordinates.x - offset.x,\n            y: rectCoordinates.y - offset.y,\n          };\n        }\n      }\n    }\n  };\n\n  const sensors = useSensors(\n    useSensor(PointerSensor),\n    useSensor(KeyboardSensor, {\n      coordinateGetter,\n      onActivation: () => {\n        isKeyboard.current = true;\n      },\n    })\n  );\n\n  return {\n    activeItemId,\n    setActiveItemId: setActiveItem,\n    collisionDetection,\n    coordinateGetter,\n    handleKeyDown,\n    sensors,\n  };\n}\n\nfunction isAfter(a: DroppableContainer, b: DroppableContainer) {\n  return hasSortableData(a) && hasSortableData(b) && a.data.current.sortable.index < b.data.current.sortable.index;\n}\n\nfunction getCollidingContainer({\n  activeId,\n  closestId,\n  droppableContainers,\n}: {\n  activeId: UniqueIdentifier;\n  closestId: UniqueIdentifier;\n  droppableContainers: DroppableContainer[];\n}) {\n  if (closestId === activeId) {\n    return;\n  }\n  const collidingContainer = droppableContainers.find(({ id }) => id === closestId);\n  if (collidingContainer) {\n    return {\n      id: collidingContainer.id,\n      data: {\n        droppableContainer: collidingContainer,\n        value: 0,\n      },\n    };\n  }\n}\n\nconst isEscape = (key: string) => key === 'Escape' || key === 'Esc';\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}