{"ast":null,"code":"import { __rest } from \"tslib\";\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useCallback, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport { TransitionGroup } from 'react-transition-group';\nimport clsx from 'clsx';\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\nimport { useUniqueId } from '@cloudscape-design/component-toolkit/internal';\nimport { getAnalyticsMetadataAttribute } from '@cloudscape-design/component-toolkit/internal/analytics-metadata';\nimport { useInternalI18n } from '../i18n/context';\nimport InternalIcon from '../icon/internal';\nimport { animate, getDOMRects } from '../internal/animate';\nimport { Transition } from '../internal/components/transition';\nimport { getVisualContextClassname } from '../internal/components/visual-context';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nimport { throttle } from '../internal/utils/throttle';\nimport { getComponentsAnalyticsMetadata, getItemAnalyticsMetadata } from './analytics-metadata/utils';\nimport { useFlashbar } from './common';\nimport { Flash, focusFlashById } from './flash';\nimport { getCollapsibleFlashStyles, getNotificationBarStyles } from './style';\nimport { counterTypes, getFlashTypeCount, getItemColor, getVisibleCollapsedItems } from './utils';\nimport styles from './styles.css.js';\n// If the number of items is equal or less than this value,\n// the toggle element will not be displayed and the Flashbar will look like a regular single-item Flashbar.\nconst maxNonCollapsibleItems = 1;\nconst resizeListenerThrottleDelay = 100;\nexport default function CollapsibleFlashbar(_a) {\n  var {\n      items,\n      style\n    } = _a,\n    restProps = __rest(_a, [\"items\", \"style\"]);\n  const [enteringItems, setEnteringItems] = useState([]);\n  const [exitingItems, setExitingItems] = useState([]);\n  const [isFlashbarStackExpanded, setIsFlashbarStackExpanded] = useState(false);\n  const getElementsToAnimate = useCallback(() => {\n    const flashElements = isFlashbarStackExpanded ? expandedItemRefs.current : collapsedItemRefs.current;\n    return Object.assign(Object.assign({}, flashElements), {\n      notificationBar: notificationBarRef.current\n    });\n  }, [isFlashbarStackExpanded]);\n  const prepareAnimations = useCallback(() => {\n    const rects = getDOMRects(getElementsToAnimate());\n    setInitialAnimationState(rects);\n  }, [getElementsToAnimate]);\n  const {\n    baseProps,\n    isReducedMotion,\n    isVisualRefresh,\n    mergedRef,\n    ref\n  } = useFlashbar(Object.assign(Object.assign({\n    items\n  }, restProps), {\n    onItemsAdded: newItems => {\n      setEnteringItems([...enteringItems, ...newItems]);\n    },\n    onItemsChanged: options => {\n      // If not all items have ID, we can still animate collapse/expand transitions\n      // because we can rely on each item's index in the original array,\n      // but we can't do that when elements are added or removed, since the index changes.\n      if ((options === null || options === void 0 ? void 0 : options.allItemsHaveId) && !(options === null || options === void 0 ? void 0 : options.isReducedMotion)) {\n        prepareAnimations();\n      }\n    },\n    onItemsRemoved: removedItems => {\n      setExitingItems([...exitingItems, ...removedItems]);\n    }\n  }));\n  const collapsedItemRefs = useRef({});\n  const expandedItemRefs = useRef({});\n  const [initialAnimationState, setInitialAnimationState] = useState(null);\n  const listElementRef = useRef(null);\n  const notificationBarRef = useRef(null);\n  const [transitioning, setTransitioning] = useState(false);\n  const flashbarElementId = useUniqueId('flashbar');\n  const itemCountElementId = useUniqueId('item-count');\n  if (items.length <= maxNonCollapsibleItems && isFlashbarStackExpanded) {\n    setIsFlashbarStackExpanded(false);\n  }\n  const animateFlash = !isReducedMotion;\n  function toggleCollapseExpand() {\n    if (!isReducedMotion) {\n      prepareAnimations();\n    }\n    setIsFlashbarStackExpanded(prev => !prev);\n  }\n  useLayoutEffect(() => {\n    if (isFlashbarStackExpanded && (items === null || items === void 0 ? void 0 : items.length)) {\n      const mostRecentItem = items[0];\n      if (mostRecentItem.id !== undefined) {\n        focusFlashById(ref.current, mostRecentItem.id);\n      }\n    }\n    // Run this after expanding, but not every time the items change.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isFlashbarStackExpanded]);\n  // When collapsing, scroll up if necessary to avoid losing track of the focused button\n  useEffectOnUpdate(() => {\n    if (!isFlashbarStackExpanded && notificationBarRef.current) {\n      scrollElementIntoView(notificationBarRef.current);\n    }\n  }, [isFlashbarStackExpanded]);\n  const updateBottomSpacing = useMemo(() => throttle(() => {\n    // Allow vertical space between Flashbar and page bottom only when the Flashbar is reaching the end of the page,\n    // otherwise avoid spacing with eventual sticky elements below.\n    const listElement = listElementRef === null || listElementRef === void 0 ? void 0 : listElementRef.current;\n    const flashbar = listElement === null || listElement === void 0 ? void 0 : listElement.parentElement;\n    if (listElement && flashbar) {\n      // Make sure the bottom padding is present when we make the calculations,\n      // then we might decide to remove it or not.\n      flashbar.classList.remove(styles.floating);\n      const windowHeight = window.innerHeight;\n      // Take the parent region into account if using the App Layout, because it might have additional margins.\n      // Otherwise we use the Flashbar component for this calculation.\n      const outerElement = findUpUntil(flashbar, element => element.getAttribute('role') === 'region') || flashbar;\n      const applySpacing = isFlashbarStackExpanded && Math.ceil(outerElement.getBoundingClientRect().bottom) >= windowHeight;\n      if (!applySpacing) {\n        flashbar.classList.add(styles.floating);\n      }\n    }\n  }, resizeListenerThrottleDelay), [isFlashbarStackExpanded]);\n  useLayoutEffect(() => {\n    window.addEventListener('resize', updateBottomSpacing);\n    return () => {\n      window.removeEventListener('resize', updateBottomSpacing);\n      updateBottomSpacing.cancel();\n    };\n  }, [updateBottomSpacing]);\n  const {\n    i18nStrings\n  } = restProps;\n  const i18n = useInternalI18n('flashbar');\n  const ariaLabel = i18n('i18nStrings.ariaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.ariaLabel);\n  const notificationBarText = i18n('i18nStrings.notificationBarText', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.notificationBarText);\n  const notificationBarAriaLabel = i18n('i18nStrings.notificationBarAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.notificationBarAriaLabel);\n  const iconAriaLabels = {\n    errorIconAriaLabel: i18n('i18nStrings.errorIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.errorIconAriaLabel),\n    inProgressIconAriaLabel: i18n('i18nStrings.inProgressIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.inProgressIconAriaLabel),\n    infoIconAriaLabel: i18n('i18nStrings.infoIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.infoIconAriaLabel),\n    successIconAriaLabel: i18n('i18nStrings.successIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.successIconAriaLabel),\n    warningIconAriaLabel: i18n('i18nStrings.warningIconAriaLabel', i18nStrings === null || i18nStrings === void 0 ? void 0 : i18nStrings.warningIconAriaLabel)\n  };\n  useLayoutEffect(() => {\n    // When `useLayoutEffect` is called, the DOM is updated but has not been painted yet,\n    // so it's a good moment to trigger animations that will make calculations based on old and new DOM state.\n    // The old state is kept in `initialAnimationState`\n    // and the new state can be retrieved from the current DOM elements.\n    if (initialAnimationState) {\n      updateBottomSpacing();\n      animate({\n        elements: getElementsToAnimate(),\n        oldState: initialAnimationState,\n        newElementInitialState: _ref => {\n          let {\n            top\n          } = _ref;\n          return {\n            scale: 0.9,\n            y: -0.2 * top\n          };\n        },\n        onTransitionsEnd: () => setTransitioning(false)\n      });\n      setTransitioning(true);\n      setInitialAnimationState(null);\n    }\n  }, [updateBottomSpacing, getElementsToAnimate, initialAnimationState, isFlashbarStackExpanded]);\n  const isCollapsible = items.length > maxNonCollapsibleItems;\n  const countByType = getFlashTypeCount(items);\n  const numberOfColorsInStack = new Set(items.map(getItemColor)).size;\n  const maxSlots = Math.max(numberOfColorsInStack, 3);\n  const stackDepth = Math.min(maxSlots, items.length);\n  const itemsToShow = isFlashbarStackExpanded ? items.map((item, index) => Object.assign(Object.assign({}, item), {\n    expandedIndex: index\n  })) : getVisibleCollapsedItems(items, stackDepth).map((item, index) => Object.assign(Object.assign({}, item), {\n    collapsedIndex: index\n  }));\n  const getItemId = item => {\n    var _a, _b;\n    return (_b = (_a = item.id) !== null && _a !== void 0 ? _a : item.expandedIndex) !== null && _b !== void 0 ? _b : 0;\n  };\n  // This check allows us to use the standard \"enter\" Transition only when the notification was not existing before.\n  // If instead it was moved to the top of the stack but was already present in the array\n  // (e.g, after dismissing another notification),\n  // we need to use different, more custom and more controlled animations.\n  const hasEntered = item => enteringItems.some(_item => _item.id && _item.id === item.id);\n  const hasLeft = item => !('expandedIndex' in item);\n  const hasEnteredOrLeft = item => hasEntered(item) || hasLeft(item);\n  const showInnerContent = item => isFlashbarStackExpanded || hasLeft(item) || 'expandedIndex' in item && item.expandedIndex === 0;\n  const shouldUseStandardAnimation = (item, index) => index === 0 && hasEnteredOrLeft(item);\n  const getAnimationElementId = item => `flash-${getItemId(item)}`;\n  const renderList = () => React.createElement(\"ul\", {\n    ref: listElementRef,\n    className: clsx(styles['flash-list'], isFlashbarStackExpanded ? styles.expanded : styles.collapsed, transitioning && styles['animation-running'], initialAnimationState && styles['animation-ready'], isVisualRefresh && styles['visual-refresh']),\n    id: flashbarElementId,\n    \"aria-label\": ariaLabel,\n    \"aria-describedby\": isCollapsible ? itemCountElementId : undefined,\n    style: !isFlashbarStackExpanded || transitioning ? {\n      [customCssProps.flashbarStackDepth]: stackDepth\n    } : undefined\n  }, React.createElement(ListWrapper, {\n    withMotion: !isReducedMotion\n  }, itemsToShow.map((item, index) => React.createElement(Transition, {\n    key: getItemId(item),\n    in: !hasLeft(item),\n    onStatusChange: status => {\n      if (status === 'entered') {\n        setEnteringItems([]);\n      } else if (status === 'exited') {\n        setExitingItems([]);\n      }\n    }\n  }, (state, transitionRootElement) => {\n    var _a, _b, _c;\n    return React.createElement(\"li\", Object.assign({\n      \"aria-hidden\": !showInnerContent(item),\n      className: showInnerContent(item) ? clsx(styles['flash-list-item'], !isFlashbarStackExpanded && styles.item, !collapsedItemRefs.current[getAnimationElementId(item)] && styles['expanded-only']) : clsx(styles.flash, styles[`flash-type-${(_a = item.type) !== null && _a !== void 0 ? _a : 'info'}`], styles.item),\n      ref: element => {\n        if (isFlashbarStackExpanded) {\n          expandedItemRefs.current[getAnimationElementId(item)] = element;\n        } else {\n          collapsedItemRefs.current[getAnimationElementId(item)] = element;\n        }\n      },\n      style: Object.assign(Object.assign({}, index > 0 && !isFlashbarStackExpanded && getCollapsibleFlashStyles(style, item.type)), (!isFlashbarStackExpanded || transitioning) && {\n        [customCssProps.flashbarStackIndex]: (_c = (_b = item.collapsedIndex) !== null && _b !== void 0 ? _b : item.expandedIndex) !== null && _c !== void 0 ? _c : index\n      }),\n      key: getItemId(item)\n    }, getAnalyticsMetadataAttribute(getItemAnalyticsMetadata(index + 1, item.type || 'info', item.id))), showInnerContent(item) && React.createElement(Flash, Object.assign({\n      className: clsx(animateFlash && styles['flash-with-motion'], isVisualRefresh && styles['flash-refresh']),\n      key: getItemId(item),\n      ref: shouldUseStandardAnimation(item, index) ? transitionRootElement : undefined,\n      transitionState: shouldUseStandardAnimation(item, index) ? state : undefined,\n      i18nStrings: iconAriaLabels,\n      style: style\n    }, item)));\n  }))));\n  return React.createElement(\"div\", Object.assign({}, baseProps, {\n    className: clsx(baseProps.className, styles.flashbar, styles.stack, isCollapsible && styles.collapsible, items.length === 2 && styles['short-list'], isFlashbarStackExpanded && styles.expanded, isVisualRefresh && styles['visual-refresh']),\n    ref: mergedRef\n  }, getAnalyticsMetadataAttribute(getComponentsAnalyticsMetadata(items.length, true, isFlashbarStackExpanded))), isFlashbarStackExpanded && renderList(), isCollapsible && React.createElement(\"div\", Object.assign({\n    className: clsx(styles['notification-bar'], isVisualRefresh && styles['visual-refresh'], isFlashbarStackExpanded ? styles.expanded : styles.collapsed, transitioning && styles['animation-running'], items.length === 2 && styles['short-list'], getVisualContextClassname('flashbar') // Visual context is needed for focus ring to be white\n    ),\n    onClick: toggleCollapseExpand,\n    ref: notificationBarRef,\n    style: getNotificationBarStyles(style)\n  }, getAnalyticsMetadataAttribute({\n    action: !isFlashbarStackExpanded ? 'expand' : 'collapse',\n    detail: {\n      label: 'h2'\n    }\n  })), React.createElement(\"span\", {\n    \"aria-live\": \"polite\",\n    className: styles.status,\n    role: \"status\",\n    id: itemCountElementId\n  }, notificationBarText && React.createElement(\"h2\", {\n    className: styles.header\n  }, notificationBarText), React.createElement(\"span\", {\n    className: styles['item-count']\n  }, counterTypes.map(_ref2 => {\n    let {\n      type,\n      labelName,\n      iconName\n    } = _ref2;\n    return React.createElement(NotificationTypeCount, {\n      key: type,\n      iconName: iconName,\n      label: iconAriaLabels[labelName],\n      count: countByType[type]\n    });\n  }))), React.createElement(\"button\", {\n    \"aria-controls\": flashbarElementId,\n    \"aria-describedby\": itemCountElementId,\n    \"aria-expanded\": isFlashbarStackExpanded,\n    \"aria-label\": notificationBarAriaLabel,\n    className: clsx(styles.button, isFlashbarStackExpanded && styles.expanded)\n  }, React.createElement(InternalIcon, {\n    className: styles.icon,\n    size: \"normal\",\n    name: \"angle-down\"\n  }))), !isFlashbarStackExpanded && renderList());\n}\nconst NotificationTypeCount = _ref3 => {\n  let {\n    iconName,\n    label,\n    count\n  } = _ref3;\n  return React.createElement(\"span\", {\n    className: styles['type-count']\n  }, React.createElement(\"span\", {\n    title: label\n  }, React.createElement(InternalIcon, {\n    name: iconName,\n    ariaLabel: label\n  })), React.createElement(\"span\", {\n    className: styles['count-number']\n  }, count));\n};\nconst ListWrapper = _ref4 => {\n  let {\n    children,\n    withMotion\n  } = _ref4;\n  return withMotion ? React.createElement(TransitionGroup, {\n    component: null\n  }, children) : React.createElement(React.Fragment, null, children);\n};","map":{"version":3,"names":["React","useCallback","useLayoutEffect","useMemo","useRef","useState","TransitionGroup","clsx","findUpUntil","useUniqueId","getAnalyticsMetadataAttribute","useInternalI18n","InternalIcon","animate","getDOMRects","Transition","getVisualContextClassname","customCssProps","useEffectOnUpdate","scrollElementIntoView","throttle","getComponentsAnalyticsMetadata","getItemAnalyticsMetadata","useFlashbar","Flash","focusFlashById","getCollapsibleFlashStyles","getNotificationBarStyles","counterTypes","getFlashTypeCount","getItemColor","getVisibleCollapsedItems","styles","maxNonCollapsibleItems","resizeListenerThrottleDelay","CollapsibleFlashbar","_a","items","style","restProps","__rest","enteringItems","setEnteringItems","exitingItems","setExitingItems","isFlashbarStackExpanded","setIsFlashbarStackExpanded","getElementsToAnimate","flashElements","expandedItemRefs","current","collapsedItemRefs","Object","assign","notificationBar","notificationBarRef","prepareAnimations","rects","setInitialAnimationState","baseProps","isReducedMotion","isVisualRefresh","mergedRef","ref","onItemsAdded","newItems","onItemsChanged","options","allItemsHaveId","onItemsRemoved","removedItems","initialAnimationState","listElementRef","transitioning","setTransitioning","flashbarElementId","itemCountElementId","length","animateFlash","toggleCollapseExpand","prev","mostRecentItem","id","undefined","updateBottomSpacing","listElement","flashbar","parentElement","classList","remove","floating","windowHeight","window","innerHeight","outerElement","element","getAttribute","applySpacing","Math","ceil","getBoundingClientRect","bottom","add","addEventListener","removeEventListener","cancel","i18nStrings","i18n","ariaLabel","notificationBarText","notificationBarAriaLabel","iconAriaLabels","errorIconAriaLabel","inProgressIconAriaLabel","infoIconAriaLabel","successIconAriaLabel","warningIconAriaLabel","elements","oldState","newElementInitialState","_ref","top","scale","y","onTransitionsEnd","isCollapsible","countByType","numberOfColorsInStack","Set","map","size","maxSlots","max","stackDepth","min","itemsToShow","item","index","expandedIndex","collapsedIndex","getItemId","_b","hasEntered","some","_item","hasLeft","hasEnteredOrLeft","showInnerContent","shouldUseStandardAnimation","getAnimationElementId","renderList","createElement","className","expanded","collapsed","flashbarStackDepth","ListWrapper","withMotion","key","in","onStatusChange","status","state","transitionRootElement","flash","type","flashbarStackIndex","_c","transitionState","stack","collapsible","onClick","action","detail","label","role","header","_ref2","labelName","iconName","NotificationTypeCount","count","button","icon","name","_ref3","title","_ref4","children","component","Fragment"],"sources":["/Users/naman/Desktop/Portfolio/react-portfolio/node_modules/src/flashbar/collapsible-flashbar.tsx"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { ReactNode, useCallback, useLayoutEffect, useMemo, useRef, useState } from 'react';\nimport { TransitionGroup } from 'react-transition-group';\nimport clsx from 'clsx';\n\nimport { findUpUntil } from '@cloudscape-design/component-toolkit/dom';\nimport { useUniqueId } from '@cloudscape-design/component-toolkit/internal';\nimport { getAnalyticsMetadataAttribute } from '@cloudscape-design/component-toolkit/internal/analytics-metadata';\n\nimport { useInternalI18n } from '../i18n/context';\nimport { IconProps } from '../icon/interfaces';\nimport InternalIcon from '../icon/internal';\nimport { animate, getDOMRects } from '../internal/animate';\nimport { Transition } from '../internal/components/transition';\nimport { getVisualContextClassname } from '../internal/components/visual-context';\nimport customCssProps from '../internal/generated/custom-css-properties';\nimport { useEffectOnUpdate } from '../internal/hooks/use-effect-on-update';\nimport { scrollElementIntoView } from '../internal/utils/scrollable-containers';\nimport { throttle } from '../internal/utils/throttle';\nimport {\n  GeneratedAnalyticsMetadataFlashbarCollapse,\n  GeneratedAnalyticsMetadataFlashbarExpand,\n} from './analytics-metadata/interfaces';\nimport { getComponentsAnalyticsMetadata, getItemAnalyticsMetadata } from './analytics-metadata/utils';\nimport { useFlashbar } from './common';\nimport { Flash, focusFlashById } from './flash';\nimport { FlashbarProps } from './interfaces';\nimport { getCollapsibleFlashStyles, getNotificationBarStyles } from './style';\nimport { counterTypes, getFlashTypeCount, getItemColor, getVisibleCollapsedItems, StackableItem } from './utils';\n\nimport styles from './styles.css.js';\n\n// If the number of items is equal or less than this value,\n// the toggle element will not be displayed and the Flashbar will look like a regular single-item Flashbar.\nconst maxNonCollapsibleItems = 1;\n\nconst resizeListenerThrottleDelay = 100;\n\nexport default function CollapsibleFlashbar({ items, style, ...restProps }: FlashbarProps) {\n  const [enteringItems, setEnteringItems] = useState<ReadonlyArray<FlashbarProps.MessageDefinition>>([]);\n  const [exitingItems, setExitingItems] = useState<ReadonlyArray<FlashbarProps.MessageDefinition>>([]);\n  const [isFlashbarStackExpanded, setIsFlashbarStackExpanded] = useState(false);\n\n  const getElementsToAnimate = useCallback(() => {\n    const flashElements = isFlashbarStackExpanded ? expandedItemRefs.current : collapsedItemRefs.current;\n    return { ...flashElements, notificationBar: notificationBarRef.current };\n  }, [isFlashbarStackExpanded]);\n\n  const prepareAnimations = useCallback(() => {\n    const rects = getDOMRects(getElementsToAnimate());\n    setInitialAnimationState(rects);\n  }, [getElementsToAnimate]);\n\n  const { baseProps, isReducedMotion, isVisualRefresh, mergedRef, ref } = useFlashbar({\n    items,\n    ...restProps,\n    onItemsAdded: newItems => {\n      setEnteringItems([...enteringItems, ...newItems]);\n    },\n    onItemsChanged: options => {\n      // If not all items have ID, we can still animate collapse/expand transitions\n      // because we can rely on each item's index in the original array,\n      // but we can't do that when elements are added or removed, since the index changes.\n      if (options?.allItemsHaveId && !options?.isReducedMotion) {\n        prepareAnimations();\n      }\n    },\n    onItemsRemoved: removedItems => {\n      setExitingItems([...exitingItems, ...removedItems]);\n    },\n  });\n\n  const collapsedItemRefs = useRef<Record<string, HTMLElement | null>>({});\n  const expandedItemRefs = useRef<Record<string, HTMLElement | null>>({});\n  const [initialAnimationState, setInitialAnimationState] = useState<Record<string, DOMRect> | null>(null);\n  const listElementRef = useRef<HTMLUListElement | null>(null);\n  const notificationBarRef = useRef<HTMLDivElement | null>(null);\n  const [transitioning, setTransitioning] = useState(false);\n  const flashbarElementId = useUniqueId('flashbar');\n  const itemCountElementId = useUniqueId('item-count');\n\n  if (items.length <= maxNonCollapsibleItems && isFlashbarStackExpanded) {\n    setIsFlashbarStackExpanded(false);\n  }\n\n  const animateFlash = !isReducedMotion;\n\n  function toggleCollapseExpand() {\n    if (!isReducedMotion) {\n      prepareAnimations();\n    }\n    setIsFlashbarStackExpanded(prev => !prev);\n  }\n\n  useLayoutEffect(() => {\n    if (isFlashbarStackExpanded && items?.length) {\n      const mostRecentItem = items[0];\n      if (mostRecentItem.id !== undefined) {\n        focusFlashById(ref.current, mostRecentItem.id);\n      }\n    }\n    // Run this after expanding, but not every time the items change.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [isFlashbarStackExpanded]);\n\n  // When collapsing, scroll up if necessary to avoid losing track of the focused button\n  useEffectOnUpdate(() => {\n    if (!isFlashbarStackExpanded && notificationBarRef.current) {\n      scrollElementIntoView(notificationBarRef.current);\n    }\n  }, [isFlashbarStackExpanded]);\n\n  const updateBottomSpacing = useMemo(\n    () =>\n      throttle(() => {\n        // Allow vertical space between Flashbar and page bottom only when the Flashbar is reaching the end of the page,\n        // otherwise avoid spacing with eventual sticky elements below.\n        const listElement = listElementRef?.current;\n        const flashbar = listElement?.parentElement;\n        if (listElement && flashbar) {\n          // Make sure the bottom padding is present when we make the calculations,\n          // then we might decide to remove it or not.\n          flashbar.classList.remove(styles.floating);\n          const windowHeight = window.innerHeight;\n          // Take the parent region into account if using the App Layout, because it might have additional margins.\n          // Otherwise we use the Flashbar component for this calculation.\n          const outerElement = findUpUntil(flashbar, element => element.getAttribute('role') === 'region') || flashbar;\n          const applySpacing =\n            isFlashbarStackExpanded && Math.ceil(outerElement.getBoundingClientRect().bottom) >= windowHeight;\n          if (!applySpacing) {\n            flashbar.classList.add(styles.floating);\n          }\n        }\n      }, resizeListenerThrottleDelay),\n    [isFlashbarStackExpanded]\n  );\n\n  useLayoutEffect(() => {\n    window.addEventListener('resize', updateBottomSpacing);\n    return () => {\n      window.removeEventListener('resize', updateBottomSpacing);\n      updateBottomSpacing.cancel();\n    };\n  }, [updateBottomSpacing]);\n\n  const { i18nStrings } = restProps;\n\n  const i18n = useInternalI18n('flashbar');\n  const ariaLabel = i18n('i18nStrings.ariaLabel', i18nStrings?.ariaLabel);\n  const notificationBarText = i18n('i18nStrings.notificationBarText', i18nStrings?.notificationBarText);\n  const notificationBarAriaLabel = i18n('i18nStrings.notificationBarAriaLabel', i18nStrings?.notificationBarAriaLabel);\n  const iconAriaLabels = {\n    errorIconAriaLabel: i18n('i18nStrings.errorIconAriaLabel', i18nStrings?.errorIconAriaLabel),\n    inProgressIconAriaLabel: i18n('i18nStrings.inProgressIconAriaLabel', i18nStrings?.inProgressIconAriaLabel),\n    infoIconAriaLabel: i18n('i18nStrings.infoIconAriaLabel', i18nStrings?.infoIconAriaLabel),\n    successIconAriaLabel: i18n('i18nStrings.successIconAriaLabel', i18nStrings?.successIconAriaLabel),\n    warningIconAriaLabel: i18n('i18nStrings.warningIconAriaLabel', i18nStrings?.warningIconAriaLabel),\n  };\n\n  useLayoutEffect(() => {\n    // When `useLayoutEffect` is called, the DOM is updated but has not been painted yet,\n    // so it's a good moment to trigger animations that will make calculations based on old and new DOM state.\n    // The old state is kept in `initialAnimationState`\n    // and the new state can be retrieved from the current DOM elements.\n\n    if (initialAnimationState) {\n      updateBottomSpacing();\n\n      animate({\n        elements: getElementsToAnimate(),\n        oldState: initialAnimationState,\n        newElementInitialState: ({ top }) => ({ scale: 0.9, y: -0.2 * top }),\n        onTransitionsEnd: () => setTransitioning(false),\n      });\n\n      setTransitioning(true);\n      setInitialAnimationState(null);\n    }\n  }, [updateBottomSpacing, getElementsToAnimate, initialAnimationState, isFlashbarStackExpanded]);\n\n  const isCollapsible = items.length > maxNonCollapsibleItems;\n\n  const countByType = getFlashTypeCount(items);\n\n  const numberOfColorsInStack = new Set(items.map(getItemColor)).size;\n  const maxSlots = Math.max(numberOfColorsInStack, 3);\n  const stackDepth = Math.min(maxSlots, items.length);\n\n  const itemsToShow = isFlashbarStackExpanded\n    ? items.map((item, index) => ({ ...item, expandedIndex: index }))\n    : getVisibleCollapsedItems(items, stackDepth).map((item: StackableItem, index: number) => ({\n        ...item,\n        collapsedIndex: index,\n      }));\n\n  const getItemId = (item: StackableItem | FlashbarProps.MessageDefinition) =>\n    item.id ?? (item as StackableItem).expandedIndex ?? 0;\n\n  // This check allows us to use the standard \"enter\" Transition only when the notification was not existing before.\n  // If instead it was moved to the top of the stack but was already present in the array\n  // (e.g, after dismissing another notification),\n  // we need to use different, more custom and more controlled animations.\n  const hasEntered = (item: StackableItem | FlashbarProps.MessageDefinition) =>\n    enteringItems.some(_item => _item.id && _item.id === item.id);\n  const hasLeft = (item: StackableItem | FlashbarProps.MessageDefinition) => !('expandedIndex' in item);\n  const hasEnteredOrLeft = (item: StackableItem | FlashbarProps.MessageDefinition) => hasEntered(item) || hasLeft(item);\n\n  const showInnerContent = (item: StackableItem | FlashbarProps.MessageDefinition) =>\n    isFlashbarStackExpanded || hasLeft(item) || ('expandedIndex' in item && item.expandedIndex === 0);\n\n  const shouldUseStandardAnimation = (item: StackableItem, index: number) => index === 0 && hasEnteredOrLeft(item);\n\n  const getAnimationElementId = (item: StackableItem) => `flash-${getItemId(item)}`;\n\n  const renderList = () => (\n    <ul\n      ref={listElementRef}\n      className={clsx(\n        styles['flash-list'],\n        isFlashbarStackExpanded ? styles.expanded : styles.collapsed,\n        transitioning && styles['animation-running'],\n        initialAnimationState && styles['animation-ready'],\n        isVisualRefresh && styles['visual-refresh']\n      )}\n      id={flashbarElementId}\n      aria-label={ariaLabel}\n      aria-describedby={isCollapsible ? itemCountElementId : undefined}\n      style={\n        !isFlashbarStackExpanded || transitioning\n          ? {\n              [customCssProps.flashbarStackDepth]: stackDepth,\n            }\n          : undefined\n      }\n    >\n      <ListWrapper withMotion={!isReducedMotion}>\n        {itemsToShow.map((item: StackableItem, index: number) => (\n          <Transition\n            key={getItemId(item)}\n            in={!hasLeft(item)}\n            onStatusChange={status => {\n              if (status === 'entered') {\n                setEnteringItems([]);\n              } else if (status === 'exited') {\n                setExitingItems([]);\n              }\n            }}\n          >\n            {(state: string, transitionRootElement: React.Ref<HTMLDivElement> | undefined) => (\n              <li\n                aria-hidden={!showInnerContent(item)}\n                className={\n                  showInnerContent(item)\n                    ? clsx(\n                        styles['flash-list-item'],\n                        !isFlashbarStackExpanded && styles.item,\n                        !collapsedItemRefs.current[getAnimationElementId(item)] && styles['expanded-only']\n                      )\n                    : clsx(styles.flash, styles[`flash-type-${item.type ?? 'info'}`], styles.item)\n                }\n                ref={element => {\n                  if (isFlashbarStackExpanded) {\n                    expandedItemRefs.current[getAnimationElementId(item)] = element;\n                  } else {\n                    collapsedItemRefs.current[getAnimationElementId(item)] = element;\n                  }\n                }}\n                style={{\n                  ...(index > 0 && !isFlashbarStackExpanded && getCollapsibleFlashStyles(style, item.type)),\n                  ...((!isFlashbarStackExpanded || transitioning) && {\n                    [customCssProps.flashbarStackIndex]:\n                      (item as StackableItem).collapsedIndex ?? (item as StackableItem).expandedIndex ?? index,\n                  }),\n                }}\n                key={getItemId(item)}\n                {...getAnalyticsMetadataAttribute(getItemAnalyticsMetadata(index + 1, item.type || 'info', item.id))}\n              >\n                {showInnerContent(item) && (\n                  <Flash\n                    className={clsx(\n                      animateFlash && styles['flash-with-motion'],\n                      isVisualRefresh && styles['flash-refresh']\n                    )}\n                    key={getItemId(item)}\n                    ref={shouldUseStandardAnimation(item, index) ? transitionRootElement : undefined}\n                    transitionState={shouldUseStandardAnimation(item, index) ? state : undefined}\n                    i18nStrings={iconAriaLabels}\n                    style={style}\n                    {...item}\n                  />\n                )}\n              </li>\n            )}\n          </Transition>\n        ))}\n      </ListWrapper>\n    </ul>\n  );\n\n  return (\n    <div\n      {...baseProps}\n      className={clsx(\n        baseProps.className,\n        styles.flashbar,\n        styles.stack,\n        isCollapsible && styles.collapsible,\n        items.length === 2 && styles['short-list'],\n        isFlashbarStackExpanded && styles.expanded,\n        isVisualRefresh && styles['visual-refresh']\n      )}\n      ref={mergedRef}\n      {...getAnalyticsMetadataAttribute(getComponentsAnalyticsMetadata(items.length, true, isFlashbarStackExpanded))}\n    >\n      {isFlashbarStackExpanded && renderList()}\n      {isCollapsible && (\n        <div\n          className={clsx(\n            styles['notification-bar'],\n            isVisualRefresh && styles['visual-refresh'],\n            isFlashbarStackExpanded ? styles.expanded : styles.collapsed,\n            transitioning && styles['animation-running'],\n            items.length === 2 && styles['short-list'],\n            getVisualContextClassname('flashbar') // Visual context is needed for focus ring to be white\n          )}\n          onClick={toggleCollapseExpand}\n          ref={notificationBarRef}\n          style={getNotificationBarStyles(style)}\n          {...getAnalyticsMetadataAttribute({\n            action: !isFlashbarStackExpanded ? 'expand' : 'collapse',\n            detail: {\n              label: 'h2',\n            },\n          } as GeneratedAnalyticsMetadataFlashbarExpand | GeneratedAnalyticsMetadataFlashbarCollapse)}\n        >\n          <span aria-live=\"polite\" className={styles.status} role=\"status\" id={itemCountElementId}>\n            {notificationBarText && <h2 className={styles.header}>{notificationBarText}</h2>}\n            <span className={styles['item-count']}>\n              {counterTypes.map(({ type, labelName, iconName }) => (\n                <NotificationTypeCount\n                  key={type}\n                  iconName={iconName}\n                  label={iconAriaLabels[labelName]}\n                  count={countByType[type]}\n                />\n              ))}\n            </span>\n          </span>\n          <button\n            aria-controls={flashbarElementId}\n            aria-describedby={itemCountElementId}\n            aria-expanded={isFlashbarStackExpanded}\n            aria-label={notificationBarAriaLabel}\n            className={clsx(styles.button, isFlashbarStackExpanded && styles.expanded)}\n          >\n            <InternalIcon className={styles.icon} size=\"normal\" name=\"angle-down\" />\n          </button>\n        </div>\n      )}\n      {!isFlashbarStackExpanded && renderList()}\n    </div>\n  );\n}\n\nconst NotificationTypeCount = ({\n  iconName,\n  label,\n  count,\n}: {\n  iconName: IconProps.Name;\n  label?: string;\n  count: number;\n}) => {\n  return (\n    <span className={styles['type-count']}>\n      <span title={label}>\n        <InternalIcon name={iconName} ariaLabel={label} />\n      </span>\n      <span className={styles['count-number']}>{count}</span>\n    </span>\n  );\n};\n\nconst ListWrapper = ({ children, withMotion }: { children: ReactNode; withMotion: boolean }) =>\n  withMotion ? <TransitionGroup component={null}>{children}</TransitionGroup> : <>{children}</>;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}