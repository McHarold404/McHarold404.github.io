{"ast":null,"code":"// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport { useEffect, useMemo, useRef } from 'react';\nimport { useVirtual as useVirtualDefault } from '../../vendor/react-virtual';\nimport stickyRangeExtractor from './sticky-range-extractor';\nconst MAX_ITEM_MOUNTS = 100;\n/**\n * The useVirtual from react-virtual@2 might produce an infinite update loop caused by setting\n * measured item sizes in the render cycle (as part of the measureRef assignment):\n *      The sum of all measured item sizes is returned as totalSize which is then set on the list container.\n *      Enforcing new container height might result in an items size change e.g. when the content wraps.\n *\n * The infinite update cycle causes React \"Maximum update depth exceeded\" error and can be additionally confirmed\n * by logging the totalSize which should then bounce between two values.\n *\n * The number of item refs assignments is limited to MAX_ITEM_MOUNTS unless items or indices change.\n * That is based on the assumption the item height stays constant after its first render.\n */\nexport function useVirtual(_ref) {\n  let {\n    items,\n    parentRef,\n    estimateSize,\n    firstItemSticky\n  } = _ref;\n  const rowVirtualizer = useVirtualDefault({\n    size: items.length,\n    parentRef,\n    estimateSize,\n    overscan: 5,\n    rangeExtractor: firstItemSticky ? stickyRangeExtractor : undefined\n  });\n  // Cache virtual item mounts to limit the amount of mounts per item.\n  const measuresCache = useRef(new WeakMap());\n  // Clear mounts cache every time indices, items, or size estimate change.\n  const indicesKey = rowVirtualizer.virtualItems.map(item => `${item.index}`).join(':');\n  useEffect(() => {\n    measuresCache.current = new WeakMap();\n  }, [indicesKey, items, estimateSize]);\n  const virtualItems = useMemo(() => rowVirtualizer.virtualItems.map(virtualItem => Object.assign(Object.assign({}, virtualItem), {\n    measureRef: node => {\n      var _a;\n      const mountedCount = (_a = measuresCache.current.get(items[virtualItem.index])) !== null && _a !== void 0 ? _a : 0;\n      if (mountedCount < MAX_ITEM_MOUNTS) {\n        virtualItem.measureRef(node);\n        measuresCache.current.set(items[virtualItem.index], mountedCount + 1);\n      }\n    }\n  })), [items, rowVirtualizer.virtualItems]);\n  return {\n    virtualItems,\n    totalSize: rowVirtualizer.totalSize,\n    scrollToIndex: rowVirtualizer.scrollToIndex\n  };\n}","map":{"version":3,"names":["useEffect","useMemo","useRef","useVirtual","useVirtualDefault","stickyRangeExtractor","MAX_ITEM_MOUNTS","_ref","items","parentRef","estimateSize","firstItemSticky","rowVirtualizer","size","length","overscan","rangeExtractor","undefined","measuresCache","WeakMap","indicesKey","virtualItems","map","item","index","join","current","virtualItem","Object","assign","measureRef","node","mountedCount","_a","get","set","totalSize","scrollToIndex"],"sources":["/Users/naman/Desktop/Portfolio/react-portfolio/node_modules/src/internal/hooks/use-virtual/index.ts"],"sourcesContent":["// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: Apache-2.0\nimport React, { useEffect, useMemo, useRef } from 'react';\n\nimport { useVirtual as useVirtualDefault, VirtualItem } from '../../vendor/react-virtual';\nimport stickyRangeExtractor from './sticky-range-extractor';\n\nconst MAX_ITEM_MOUNTS = 100;\n\ninterface UseVirtualProps<Item> {\n  items: readonly Item[];\n  parentRef: React.RefObject<HTMLElement>;\n  estimateSize: () => number;\n  firstItemSticky?: boolean;\n}\n\ninterface RowVirtualizer {\n  virtualItems: VirtualItem[];\n  totalSize: number;\n  scrollToIndex: (index: number) => void;\n}\n\n/**\n * The useVirtual from react-virtual@2 might produce an infinite update loop caused by setting\n * measured item sizes in the render cycle (as part of the measureRef assignment):\n *      The sum of all measured item sizes is returned as totalSize which is then set on the list container.\n *      Enforcing new container height might result in an items size change e.g. when the content wraps.\n *\n * The infinite update cycle causes React \"Maximum update depth exceeded\" error and can be additionally confirmed\n * by logging the totalSize which should then bounce between two values.\n *\n * The number of item refs assignments is limited to MAX_ITEM_MOUNTS unless items or indices change.\n * That is based on the assumption the item height stays constant after its first render.\n */\nexport function useVirtual<Item extends object>({\n  items,\n  parentRef,\n  estimateSize,\n  firstItemSticky,\n}: UseVirtualProps<Item>): RowVirtualizer {\n  const rowVirtualizer = useVirtualDefault({\n    size: items.length,\n    parentRef,\n    estimateSize,\n    overscan: 5,\n    rangeExtractor: firstItemSticky ? stickyRangeExtractor : undefined,\n  });\n\n  // Cache virtual item mounts to limit the amount of mounts per item.\n  const measuresCache = useRef(new WeakMap<Item, number>());\n\n  // Clear mounts cache every time indices, items, or size estimate change.\n  const indicesKey = rowVirtualizer.virtualItems.map(item => `${item.index}`).join(':');\n  useEffect(() => {\n    measuresCache.current = new WeakMap();\n  }, [indicesKey, items, estimateSize]);\n\n  const virtualItems = useMemo(\n    () =>\n      rowVirtualizer.virtualItems.map(virtualItem => ({\n        ...virtualItem,\n        measureRef: (node: null | HTMLElement) => {\n          const mountedCount = measuresCache.current.get(items[virtualItem.index]) ?? 0;\n          if (mountedCount < MAX_ITEM_MOUNTS) {\n            virtualItem.measureRef(node);\n            measuresCache.current.set(items[virtualItem.index], mountedCount + 1);\n          }\n        },\n      })),\n    [items, rowVirtualizer.virtualItems]\n  );\n\n  return {\n    virtualItems,\n    totalSize: rowVirtualizer.totalSize,\n    scrollToIndex: rowVirtualizer.scrollToIndex,\n  };\n}\n"],"mappings":"AAAA;AACA;AACA,SAAgBA,SAAS,EAAEC,OAAO,EAAEC,MAAM,QAAQ,OAAO;AAEzD,SAASC,UAAU,IAAIC,iBAAiB,QAAqB,4BAA4B;AACzF,OAAOC,oBAAoB,MAAM,0BAA0B;AAE3D,MAAMC,eAAe,GAAG,GAAG;AAe3B;;;;;;;;;;;;AAYA,OAAM,SAAUH,UAAUA,CAAAI,IAAA,EAKF;EAAA,IALwB;IAC9CC,KAAK;IACLC,SAAS;IACTC,YAAY;IACZC;EAAe,CACO,GAAAJ,IAAA;EACtB,MAAMK,cAAc,GAAGR,iBAAiB,CAAC;IACvCS,IAAI,EAAEL,KAAK,CAACM,MAAM;IAClBL,SAAS;IACTC,YAAY;IACZK,QAAQ,EAAE,CAAC;IACXC,cAAc,EAAEL,eAAe,GAAGN,oBAAoB,GAAGY;GAC1D,CAAC;EAEF;EACA,MAAMC,aAAa,GAAGhB,MAAM,CAAC,IAAIiB,OAAO,EAAgB,CAAC;EAEzD;EACA,MAAMC,UAAU,GAAGR,cAAc,CAACS,YAAY,CAACC,GAAG,CAACC,IAAI,IAAI,GAAGA,IAAI,CAACC,KAAK,EAAE,CAAC,CAACC,IAAI,CAAC,GAAG,CAAC;EACrFzB,SAAS,CAAC,MAAK;IACbkB,aAAa,CAACQ,OAAO,GAAG,IAAIP,OAAO,EAAE;EACvC,CAAC,EAAE,CAACC,UAAU,EAAEZ,KAAK,EAAEE,YAAY,CAAC,CAAC;EAErC,MAAMW,YAAY,GAAGpB,OAAO,CAC1B,MACEW,cAAc,CAACS,YAAY,CAACC,GAAG,CAACK,WAAW,IAAIC,MAAA,CAAAC,MAAA,CAAAD,MAAA,CAAAC,MAAA,KAC1CF,WAAW;IACdG,UAAU,EAAGC,IAAwB,IAAI;;MACvC,MAAMC,YAAY,GAAG,CAAAC,EAAA,GAAAf,aAAa,CAACQ,OAAO,CAACQ,GAAG,CAAC1B,KAAK,CAACmB,WAAW,CAACH,KAAK,CAAC,CAAC,cAAAS,EAAA,cAAAA,EAAA,GAAI,CAAC;MAC7E,IAAID,YAAY,GAAG1B,eAAe,EAAE;QAClCqB,WAAW,CAACG,UAAU,CAACC,IAAI,CAAC;QAC5Bb,aAAa,CAACQ,OAAO,CAACS,GAAG,CAAC3B,KAAK,CAACmB,WAAW,CAACH,KAAK,CAAC,EAAEQ,YAAY,GAAG,CAAC,CAAC;;IAEzE;EAAC,EACD,CAAC,EACL,CAACxB,KAAK,EAAEI,cAAc,CAACS,YAAY,CAAC,CACrC;EAED,OAAO;IACLA,YAAY;IACZe,SAAS,EAAExB,cAAc,CAACwB,SAAS;IACnCC,aAAa,EAAEzB,cAAc,CAACyB;GAC/B;AACH","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}